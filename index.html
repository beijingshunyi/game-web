<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>万花消消乐 - Telegram小游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // 配置Tailwind自定义主题
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#8B5CF6', // 主色调：紫色
                        secondary: '#EC4899', // 辅助色：粉色
                        accent: '#F59E0B', // 强调色：橙色
                        background: '#FEF3C7', // 背景色：浅黄色
                        board: '#FFFBEB', // 棋盘背景色
                    },
                    fontFamily: {
                        game: ['"Comic Sans MS"', '"Marker Felt"', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .game-shadow {
                box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            }
            .tile-shadow {
                box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1);
            }
            .animate-pop {
                animation: pop 0.3s ease-out;
            }
            .animate-clear {
                animation: clear 0.5s ease-in-out;
            }
            .animate-fall {
                transition: transform 0.5s ease-out;
            }
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes clear {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }
    </style>
</head>
<body class="bg-background min-h-screen font-game text-gray-800 overflow-x-hidden">
    <!-- 顶部导航 -->
    <header class="bg-gradient-to-r from-primary to-secondary text-white shadow-lg">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fa fa-gamepad text-2xl"></i>
                <h1 class="text-xl md:text-2xl font-bold">万花消消乐</h1>
            </div>
            <div class="flex items-center space-x-4">
                <div class="flex items-center space-x-1">
                    <i class="fa fa-diamond text-accent"></i>
                    <span id="coin-count" class="font-bold">0</span>
                </div>
                <div class="flex items-center space-x-1">
                    <i class="fa fa-map-signs"></i>
                    <span id="level-display">关卡: 1</span>
                </div>
                <button id="user-btn" class="bg-white/20 hover:bg-white/30 rounded-full w-8 h-8 flex items-center justify-center transition-all">
                    <i class="fa fa-user"></i>
                </button>
            </div>
        </div>
    </header>

    <!-- 游戏状态区 -->
    <div class="container mx-auto px-4 py-4">
        <div class="bg-white rounded-xl p-4 game-shadow mb-4">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div class="mb-3 md:mb-0">
                    <h2 class="text-lg font-bold">目标: 获得 <span id="target-score" class="text-accent">500</span> 分</h2>
                </div>
                <div class="flex space-x-6">
                    <div class="text-center">
                        <div class="text-sm opacity-70">当前得分</div>
                        <div id="current-score" class="text-2xl font-bold text-primary">0</div>
                    </div>
                    <div class="text-center">
                        <div class="text-sm opacity-70">剩余步数</div>
                        <div id="remaining-moves" class="text-2xl font-bold text-secondary">20</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 游戏主区域 -->
        <div class="flex flex-col md:flex-row gap-4">
            <!-- 游戏棋盘 -->
            <div class="flex-1">
                <div class="relative bg-board rounded-xl p-4 md:p-6 game-shadow aspect-square max-w-md mx-auto">
                    <div id="game-board" class="grid grid-cols-5 gap-1 w-full h-full">
                        <!-- 游戏方块将通过JS动态生成 -->
                    </div>
                    
                    <!-- 游戏结束遮罩 -->
                    <div id="game-over" class="absolute inset-0 bg-black/70 rounded-xl flex flex-col items-center justify-center hidden">
                        <h2 id="game-over-title" class="text-white text-3xl font-bold mb-4"></h2>
                        <p id="game-over-message" class="text-white text-xl mb-6"></p>
                        <div class="flex space-x-3">
                            <button id="retry-btn" class="bg-primary hover:bg-primary/90 text-white px-6 py-2 rounded-lg transition-all">
                                重试
                            </button>
                            <button id="next-level-btn" class="bg-secondary hover:bg-secondary/90 text-white px-6 py-2 rounded-lg transition-all hidden">
                                下一关
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 侧边栏 -->
            <div class="w-full md:w-64 space-y-4">
                <!-- 道具区 -->
                <div class="bg-white rounded-xl p-4 game-shadow">
                    <h3 class="text-lg font-bold mb-3 flex items-center">
                        <i class="fa fa-magic text-accent mr-2"></i>道具
                    </h3>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="prop-btn flex flex-col items-center p-2 rounded-lg border border-gray-200 hover:border-primary transition-all" data-prop="shuffle">
                            <i class="fa fa-refresh text-xl mb-1"></i>
                            <span class="text-xs">洗牌</span>
                            <span class="text-xs text-primary">30</span>
                        </button>
                        <button class="prop-btn flex flex-col items-center p-2 rounded-lg border border-gray-200 hover:border-primary transition-all" data-prop="boom">
                            <i class="fa fa-bomb text-xl mb-1"></i>
                            <span class="text-xs">爆炸</span>
                            <span class="text-xs text-primary">60</span>
                        </button>
                        <button class="prop-btn flex flex-col items-center p-2 rounded-lg border border-gray-200 hover:border-primary transition-all" data-prop="add_step">
                            <i class="fa fa-plus-circle text-xl mb-1"></i>
                            <span class="text-xs">加步</span>
                            <span class="text-xs text-primary">40</span>
                        </button>
                    </div>
                </div>

                <!-- 任务区 -->
                <div class="bg-white rounded-xl p-4 game-shadow">
                    <h3 class="text-lg font-bold mb-3 flex items-center">
                        <i class="fa fa-tasks text-accent mr-2"></i>每日任务
                    </h3>
                    <ul class="space-y-2 text-sm">
                        <li class="flex items-center">
                            <i class="fa fa-check-circle text-green-500 mr-2"></i>
                            <span>完成3局游戏</span>
                        </li>
                        <li class="flex items-center">
                            <i class="fa fa-circle-o text-gray-300 mr-2"></i>
                            <span>合成1个十字特效</span>
                        </li>
                        <li class="flex items-center">
                            <i class="fa fa-circle-o text-gray-300 mr-2"></i>
                            <span>获得1000分</span>
                        </li>
                    </ul>
                    <button class="mt-3 w-full bg-primary/10 hover:bg-primary/20 text-primary rounded-lg py-1 text-sm transition-all">
                        领取奖励
                    </button>
                </div>

                <!-- 好友排行 -->
                <div class="bg-white rounded-xl p-4 game-shadow">
                    <h3 class="text-lg font-bold mb-3 flex items-center">
                        <i class="fa fa-trophy text-accent mr-2"></i>好友排行
                    </h3>
                    <ul class="space-y-2">
                        <li class="flex items-center">
                            <div class="w-6 h-6 bg-yellow-100 text-yellow-600 rounded-full flex items-center justify-center text-xs font-bold mr-2">1</div>
                            <span class="flex-1">Telegram用户1</span>
                            <span class="font-bold">5200分</span>
                        </li>
                        <li class="flex items-center">
                            <div class="w-6 h-6 bg-gray-200 text-gray-600 rounded-full flex items-center justify-center text-xs font-bold mr-2">2</div>
                            <span class="flex-1">Telegram用户2</span>
                            <span class="font-bold">4850分</span>
                        </li>
                        <li class="flex items-center">
                            <div class="w-6 h-6 bg-amber-700 text-white rounded-full flex items-center justify-center text-xs font-bold mr-2">3</div>
                            <span class="flex-1">你</span>
                            <span class="font-bold">4500分</span>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- 底部信息 -->
    <footer class="mt-8 bg-white py-4 border-t">
        <div class="container mx-auto px-4 text-center">
            <p class="text-gray-600">
                本游戏由北京修车【万花楼】赞助 
                由 <a href="https://t.me/bjxc010" target="_blank" class="text-primary hover:underline">@bjxc010</a> 开发
            </p>
            <div class="flex justify-center space-x-4 mt-2">
                <button class="text-gray-500 hover:text-primary transition-colors">
                    <i class="fa fa-share-alt mr-1"></i>分享游戏
                </button>
                <button class="text-gray-500 hover:text-primary transition-colors">
                    <i class="fa fa-question-circle mr-1"></i>帮助
                </button>
                <button class="text-gray-500 hover:text-primary transition-colors">
                    <i class="fa fa-cog mr-1"></i>设置
                </button>
            </div>
        </div>
    </footer>

    <!-- 登录模态框 -->
    <div id="login-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 w-full max-w-md game-shadow">
            <h3 class="text-xl font-bold mb-4">登录游戏</h3>
            <p class="text-gray-600 mb-6">通过Telegram账号登录，同步你的游戏进度</p>
            <button id="telegram-login" class="w-full bg-blue-500 hover:bg-blue-600 text-white py-3 rounded-lg flex items-center justify-center transition-all">
                <i class="fa fa-telegram text-2xl mr-2"></i>
                用Telegram登录
            </button>
            <button id="close-login" class="w-full mt-3 bg-gray-100 hover:bg-gray-200 text-gray-800 py-2 rounded-lg transition-all">
                稍后登录
            </button>
        </div>
    </div>

    <script>
        // 游戏配置和状态
        const gameConfig = {
            gridSize: 5, // 5x5网格
            elements: ['flower', 'star', 'moon', 'sun', 'gem', 'bell'],
            baseScore: 10,
            currentLevel: 1,
            targetScore: 500,
            moves: 20
        };

        const gameState = {
            board: [],
            score: 0,
            remainingMoves: gameConfig.moves,
            selectedTile: null,
            isProcessing: false,
            coins: 0,
            props: {
                shuffle: 0,
                boom: 0,
                add_step: 0
            }
        };

        // 初始化Supabase
        const supabaseUrl = 'https://ylnfjlltesnlfanrxfoy.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlsbmZqbGx0ZXNubGZhbnJ4Zm95Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYxMDc0MjMsImV4cCI6MjA3MTY4MzQyM30.czuQwYoFd7Ew9f-PBaojhsWJkXrBEtkqTRdhfX-DWFk';
        const supabase = supabase.createClient(supabaseUrl, supabaseKey);

        // Telegram配置
        const BOT_TOKEN = "7058588982:AAGaWY3tDT7np7-rwAp350i6gBhC0d_UxjI";
        const BOT_USERNAME = "bjxcwhljiluBot";
        const ADMIN_ID = "8392100400";

        // DOM元素
        const gameBoard = document.getElementById('game-board');
        const currentScoreEl = document.getElementById('current-score');
        const remainingMovesEl = document.getElementById('remaining-moves');
        const targetScoreEl = document.getElementById('target-score');
        const coinCountEl = document.getElementById('coin-count');
        const levelDisplayEl = document.getElementById('level-display');
        const gameOverEl = document.getElementById('game-over');
        const gameOverTitleEl = document.getElementById('game-over-title');
        const gameOverMessageEl = document.getElementById('game-over-message');
        const retryBtn = document.getElementById('retry-btn');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const userBtn = document.getElementById('user-btn');
        const loginModal = document.getElementById('login-modal');
        const telegramLoginBtn = document.getElementById('telegram-login');
        const closeLoginBtn = document.getElementById('close-login');
        const propBtns = document.querySelectorAll('.prop-btn');

        // 元素图标映射
        const elementIcons = {
            flower: 'fa-pagelines',
            star: 'fa-star',
            moon: 'fa-moon-o',
            sun: 'fa-sun-o',
            gem: 'fa-diamond',
            bell: 'fa-bell'
        };

        // 元素颜色映射
        const elementColors = {
            flower: 'text-green-500',
            star: 'text-purple-500',
            moon: 'text-blue-500',
            sun: 'text-yellow-500',
            gem: 'text-red-500',
            bell: 'text-amber-500'
        };

        // 初始化游戏
        function initGame() {
            // 重置游戏状态
            gameState.score = 0;
            gameState.remainingMoves = gameConfig.moves;
            gameState.selectedTile = null;
            gameState.isProcessing = false;
            
            // 更新UI
            updateScore();
            updateRemainingMoves();
            targetScoreEl.textContent = gameConfig.targetScore;
            levelDisplayEl.textContent = `关卡: ${gameConfig.currentLevel}`;
            
            // 生成游戏板
            generateBoard();
            
            // 检查初始是否有可消除的组合，如果有则重新生成
            while (checkForMatches().length > 0) {
                generateBoard();
            }
            
            // 渲染游戏板
            renderBoard();
            
            // 隐藏游戏结束界面
            gameOverEl.classList.add('hidden');
        }

        // 生成游戏板
        function generateBoard() {
            gameState.board = [];
            for (let row = 0; row < gameConfig.gridSize; row++) {
                const currentRow = [];
                for (let col = 0; col < gameConfig.gridSize; col++) {
                    // 确保不会在初始状态下生成可消除的组合
                    let validElements = [...gameConfig.elements];
                    
                    // 检查左侧两个元素，避免横向三连
                    if (col >= 2) {
                        if (currentRow[col-1] === currentRow[col-2]) {
                            validElements = validElements.filter(el => el !== currentRow[col-1]);
                        }
                    }
                    
                    // 检查上方两个元素，避免纵向三连
                    if (row >= 2) {
                        if (gameState.board[row-1][col] === gameState.board[row-2][col]) {
                            validElements = validElements.filter(el => el !== gameState.board[row-1][col]);
                        }
                    }
                    
                    // 随机选择一个有效的元素
                    const randomIndex = Math.floor(Math.random() * validElements.length);
                    currentRow.push(validElements[randomIndex]);
                }
                gameState.board.push(currentRow);
            }
        }

        // 渲染游戏板
        function renderBoard() {
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${gameConfig.gridSize}, 1fr)`;
            
            for (let row = 0; row < gameConfig.gridSize; row++) {
                for (let col = 0; col < gameConfig.gridSize; col++) {
                    const element = gameState.board[row][col];
                    const tile = document.createElement('div');
                    tile.className = `tile bg-white rounded-lg flex items-center justify-center tile-shadow cursor-pointer hover:scale-105 transition-transform`;
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    
                    const icon = document.createElement('i');
                    icon.className = `fa ${elementIcons[element]} text-2xl md:text-3xl ${elementColors[element]}`;
                    tile.appendChild(icon);
                    
                    tile.addEventListener('click', () => handleTileClick(row, col));
                    
                    gameBoard.appendChild(tile);
                }
            }
        }

        // 处理方块点击
        function handleTileClick(row, col) {
            if (gameState.isProcessing) return;
            
            // 如果没有选中的方块，选中当前方块
            if (!gameState.selectedTile) {
                gameState.selectedTile = { row, col };
                highlightSelectedTile(row, col);
                return;
            }
            
            // 如果点击的是已经选中的方块，取消选中
            if (gameState.selectedTile.row === row && gameState.selectedTile.col === col) {
                gameState.selectedTile = null;
                removeHighlights();
                return;
            }
            
            // 检查是否相邻（上下左右）
            const isAdjacent = 
                (Math.abs(gameState.selectedTile.row - row) === 1 && gameState.selectedTile.col === col) ||
                (Math.abs(gameState.selectedTile.col - col) === 1 && gameState.selectedTile.row === row);
            
            if (!isAdjacent) {
                // 不相邻，选中新的方块
                gameState.selectedTile = { row, col };
                removeHighlights();
                highlightSelectedTile(row, col);
                return;
            }
            
            // 相邻，尝试交换
            swapTiles(gameState.selectedTile.row, gameState.selectedTile.col, row, col);
        }

        // 高亮选中的方块
        function highlightSelectedTile(row, col) {
            const tiles = document.querySelectorAll('.tile');
            const index = row * gameConfig.gridSize + col;
            tiles[index].classList.add('ring-4', 'ring-accent', 'scale-110');
        }

        // 移除所有高亮
        function removeHighlights() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.remove('ring-4', 'ring-accent', 'scale-110');
            });
        }

        // 交换方块
        function swapTiles(row1, col1, row2, col2) {
            gameState.isProcessing = true;
            
            // 交换数据
            const temp = gameState.board[row1][col1];
            gameState.board[row1][col1] = gameState.board[row2][col2];
            gameState.board[row2][col2] = temp;
            
            // 重新渲染
            renderBoard();
            
            // 检查是否有匹配
            setTimeout(() => {
                const matches = checkForMatches();
                
                if (matches.length > 0) {
                    // 有匹配，处理消除
                    processMatches(matches);
                    gameState.remainingMoves--;
                    updateRemainingMoves();
                    
                    // 检查游戏是否结束
                    checkGameStatus();
                } else {
                    // 没有匹配，交换回来
                    const temp = gameState.board[row1][col1];
                    gameState.board[row1][col1] = gameState.board[row2][col2];
                    gameState.board[row2][col2] = temp;
                    
                    // 重新渲染
                    renderBoard();
                    
                    // 添加动画效果表示无效交换
                    const tiles = document.querySelectorAll('.tile');
                    const index1 = row1 * gameConfig.gridSize + col1;
                    const index2 = row2 * gameConfig.gridSize + col2;
                    tiles[index1].classList.add('animate-shake');
                    tiles[index2].classList.add('animate-shake');
                    
                    setTimeout(() => {
                        tiles[index1].classList.remove('animate-shake');
                        tiles[index2].classList.remove('animate-shake');
                        gameState.isProcessing = false;
                    }, 500);
                }
                
                // 重置选中状态
                gameState.selectedTile = null;
                removeHighlights();
            }, 300);
        }

        // 检查匹配
        function checkForMatches() {
            const matches = [];
            
            // 检查水平匹配
            for (let row = 0; row < gameConfig.gridSize; row++) {
                let col = 0;
                while (col < gameConfig.gridSize - 2) {
                    const current = gameState.board[row][col];
                    if (current && 
                        current === gameState.board[row][col + 1] && 
                        current === gameState.board[row][col + 2]) {
                        
                        // 找到匹配，检查是否有更长的匹配
                        let matchLength = 3;
                        let nextCol = col + 3;
                        
                        while (nextCol < gameConfig.gridSize && gameState.board[row][nextCol] === current) {
                            matchLength++;
                            nextCol++;
                        }
                        
                        // 添加匹配的位置
                        for (let i = 0; i < matchLength; i++) {
                            matches.push({ row, col: col + i, type: getSpecialType(matchLength, 'horizontal') });
                        }
                        
                        col = nextCol;
                    } else {
                        col++;
                    }
                }
            }
            
            // 检查垂直匹配
            for (let col = 0; col < gameConfig.gridSize; col++) {
                let row = 0;
                while (row < gameConfig.gridSize - 2) {
                    const current = gameState.board[row][col];
                    if (current && 
                        current === gameState.board[row + 1][col] && 
                        current === gameState.board[row + 2][col]) {
                        
                        // 找到匹配，检查是否有更长的匹配
                        let matchLength = 3;
                        let nextRow = row + 3;
                        
                        while (nextRow < gameConfig.gridSize && gameState.board[nextRow][col] === current) {
                            matchLength++;
                            nextRow++;
                        }
                        
                        // 添加匹配的位置
                        for (let i = 0; i < matchLength; i++) {
                            matches.push({ row: row + i, col, type: getSpecialType(matchLength, 'vertical') });
                        }
                        
                        row = nextRow;
                    } else {
                        row++;
                    }
                }
            }
            
            // TODO: 检查L/T型匹配
            
            return matches;
        }

        // 确定特殊类型
        function getSpecialType(matchLength, direction) {
            if (matchLength >= 5) {
                return 'boom'; // 爆炸特效
            } else if (matchLength >= 4) {
                return 'line'; // 直线特效
            }
            return 'normal'; // 普通消除
        }

        // 处理匹配
        function processMatches(matches) {
            if (matches.length === 0) {
                gameState.isProcessing = false;
                return;
            }
            
            // 计算得分
            const scoreToAdd = matches.length * gameConfig.baseScore;
            gameState.score += scoreToAdd;
            updateScore();
            
            // 添加消除动画
            const tiles = document.querySelectorAll('.tile');
            matches.forEach(match => {
                const index = match.row * gameConfig.gridSize + match.col;
                tiles[index].classList.add('animate-clear');
            });
            
            // 移除匹配的元素
            setTimeout(() => {
                matches.forEach(match => {
                    gameState.board[match.row][match.col] = null;
                });
                
                // 让元素下落
                dropElements();
                
                // 填充新元素
                setTimeout(() => {
                    fillEmptySpaces();
                    
                    // 检查是否有新的匹配
                    setTimeout(() => {
                        const newMatches = checkForMatches();
                        processMatches(newMatches);
                    }, 500);
                }, 500);
            }, 500);
        }

        // 让元素下落
        function dropElements() {
            for (let col = 0; col < gameConfig.gridSize; col++) {
                for (let row = gameConfig.gridSize - 1; row > 0; row--) {
                    if (gameState.board[row][col] === null) {
                        // 找到当前列上方第一个非空元素
                        for (let r = row - 1; r >= 0; r--) {
                            if (gameState.board[r][col] !== null) {
                                // 下落
                                gameState.board[row][col] = gameState.board[r][col];
                                gameState.board[r][col] = null;
                                break;
                            }
                        }
                    }
                }
            }
            
            renderBoard();
        }

        // 填充空白位置
        function fillEmptySpaces() {
            for (let row = 0; row < gameConfig.gridSize; row++) {
                for (let col = 0; col < gameConfig.gridSize; col++) {
                    if (gameState.board[row][col] === null) {
                        // 随机选择一个元素
                        const randomIndex = Math.floor(Math.random() * gameConfig.elements.length);
                        gameState.board[row][col] = gameConfig.elements[randomIndex];
                    }
                }
            }
            
            renderBoard();
        }

        // 更新分数
        function updateScore() {
            currentScoreEl.textContent = gameState.score;
            
            // 添加分数变化动画
            currentScoreEl.classList.add('animate-pop');
            setTimeout(() => {
                currentScoreEl.classList.remove('animate-pop');
            }, 300);
        }

        // 更新剩余步数
        function updateRemainingMoves() {
            remainingMovesEl.textContent = gameState.remainingMoves;
            
            // 步数较少时添加警告颜色
            if (gameState.remainingMoves <= 5) {
                remainingMovesEl.classList.add('text-red-500');
            } else {
                remainingMovesEl.classList.remove('text-red-500');
            }
        }

        // 检查游戏状态
        function checkGameStatus() {
            if (gameState.remainingMoves <= 0) {
                // 步数用完
                if (gameState.score >= gameConfig.targetScore) {
                    // 通关
                    endGame(true);
                } else {
                    // 未通关
                    endGame(false);
                }
            } else if (gameState.score >= gameConfig.targetScore) {
                // 提前完成目标
                endGame(true);
            }
        }

        // 游戏结束
        function endGame(isWin) {
            gameState.isProcessing = true;
            
            if (isWin) {
                gameOverTitleEl.textContent = '恭喜过关！';
                gameOverMessageEl.textContent = `得分: ${gameState.score} 分，获得 ${Math.floor(gameState.score / 10)} 万花币`;
                
                // 增加万花币
                gameState.coins += Math.floor(gameState.score / 10);
                coinCountEl.textContent = gameState.coins;
                
                // 显示下一关按钮
                nextLevelBtn.classList.remove('hidden');
            } else {
                gameOverTitleEl.textContent = '游戏结束';
                gameOverMessageEl.textContent = `得分: ${gameState.score} 分，目标: ${gameConfig.targetScore} 分`;
                nextLevelBtn.classList.add('hidden');
            }
            
            // 显示游戏结束界面
            gameOverEl.classList.remove('hidden');
            
            // 保存游戏进度到数据库
            saveGameProgress(isWin);
        }

        // 保存游戏进度到数据库
        async function saveGameProgress(isWin) {
            try {
                // 这里应该先获取用户ID，实际应用中需要实现登录逻辑
                const userId = 'guest'; // 临时使用guest作为用户ID
                
                if (isWin && gameConfig.currentLevel > localStorage.getItem('maxLevel')) {
                    localStorage.setItem('maxLevel', gameConfig.currentLevel);
                }
                
                // 保存游戏记录
                const { data, error } = await supabase
                    .from('game_records')
                    .insert([
                        { 
                            user_id: userId, 
                            level: gameConfig.currentLevel, 
                            score: gameState.score, 
                            is_win: isWin,
                            coins_earned: isWin ? Math.floor(gameState.score / 10) : 0
                        }
                    ]);
                
                if (error) throw error;
                
                // 更新用户信息
                if (isWin) {
                    const { error: userError } = await supabase
                        .from('users')
                        .upsert([
                            { 
                                user_id: userId, 
                                max_level: Math.max(gameConfig.currentLevel, parseInt(localStorage.getItem('maxLevel') || 0)),
                                kaleido_coins: gameState.coins
                            }
                        ]);
                        
                    if (userError) throw userError;
                }
            } catch (error) {
                console.error('保存游戏进度失败:', error);
            }
        }

        // 加载用户数据
        async function loadUserData() {
            try {
                // 这里应该先获取用户ID，实际应用中需要实现登录逻辑
                const userId = 'guest'; // 临时使用guest作为用户ID
                
                const { data, error } = await supabase
                    .from('users')
                    .select('*')
                    .eq('user_id', userId)
                    .single();
                
                if (error) {
                    // 用户不存在，创建新用户
                    await supabase
                        .from('users')
                        .insert([
                            { user_id: userId, max_level: 1, kaleido_coins: 0 }
                        ]);
                        
                    gameState.coins = 0;
                    gameConfig.currentLevel = 1;
                } else {
                    gameState.coins = data.kaleido_coins;
                    gameConfig.currentLevel = data.max_level;
                }
                
                // 更新UI
                coinCountEl.textContent = gameState.coins;
                levelDisplayEl.textContent = `关卡: ${gameConfig.currentLevel}`;
                
                // 从本地存储加载最大关卡
                const savedMaxLevel = localStorage.getItem('maxLevel');
                if (savedMaxLevel) {
                    gameConfig.currentLevel = parseInt(savedMaxLevel);
                }
                
                // 设置关卡目标
                gameConfig.targetScore = 500 + (gameConfig.currentLevel - 1) * 100;
                targetScoreEl.textContent = gameConfig.targetScore;
                
            } catch (error) {
                console.error('加载用户数据失败:', error);
                // 失败时使用默认值
                gameState.coins = 0;
                gameConfig.currentLevel = 1;
                coinCountEl.textContent = gameState.coins;
            }
        }

        // 进入下一关
        function nextLevel() {
            gameConfig.currentLevel++;
            
            // 每20关增加棋盘大小
            if (gameConfig.currentLevel === 21) {
                gameConfig.gridSize = 6;
            }
            
            // 增加难度
            gameConfig.targetScore = 500 + (gameConfig.currentLevel - 1) * 100;
            gameConfig.moves = Math.max(10, 20 - Math.floor((gameConfig.currentLevel - 1) / 5));
            
            // 保存最大关卡
            localStorage.setItem('maxLevel', gameConfig.currentLevel);
            
            // 重新开始游戏
            initGame();
        }

        // 使用道具
        function useProp(propType) {
            if (gameState.isProcessing) return;
            
            // 检查是否有足够的道具
            if (gameState.props[propType] <= 0) {
                // 提示购买道具
                if (gameState.coins >= getPropCost(propType)) {
                    if (confirm(`是否花费 ${getPropCost(propType)} 万花币购买该道具?`)) {
                        gameState.coins -= getPropCost(propType);
                        gameState.props[propType]++;
                        coinCountEl.textContent = gameState.coins;
                    } else {
                        return;
                    }
                } else {
                    alert('道具不足，且万花币不够购买');
                    return;
                }
            }
            
            // 使用道具
            gameState.props[propType]--;
            
            switch(propType) {
                case 'shuffle':
                    // 洗牌道具
                    shuffleBoard();
                    break;
                case 'boom':
                    // 爆炸道具 - 让用户选择位置
                    selectBoomPosition();
                    break;
                case 'add_step':
                    // 增加步数
                    gameState.remainingMoves += 5;
                    updateRemainingMoves();
                    break;
            }
            
            // 更新道具显示
            updatePropDisplay();
        }

        // 获取道具成本
        function getPropCost(propType) {
            const costs = {
                shuffle: 30,
                boom: 60,
                add_step: 40
            };
            return costs[propType] || 0;
        }

        // 更新道具显示
        function updatePropDisplay() {
            propBtns.forEach(btn => {
                const propType = btn.dataset.prop;
                const costEl = btn.querySelector('.text-primary');
                // 这里简化处理，实际应该显示拥有的数量/成本
                costEl.textContent = gameState.props[propType] > 0 ? gameState.props[propType] : getPropCost(propType);
            });
        }

        // 洗牌
        function shuffleBoard() {
            gameState.isProcessing = true;
            
            // 保存当前分数和步数
            const currentScore = gameState.score;
            const currentMoves = gameState.remainingMoves;
            
            // 重新生成棋盘
            generateBoard();
            
            // 确保不会生成无匹配的棋盘
            while (checkForMatches().length === 0) {
                generateBoard();
            }
            
            // 渲染新棋盘
            renderBoard();
            
            // 恢复状态
            gameState.score = currentScore;
            gameState.remainingMoves = currentMoves;
            gameState.isProcessing = false;
        }

        // 选择爆炸位置
        function selectBoomPosition() {
            gameState.isProcessing = true;
            alert('请点击要爆炸的位置');
            
            // 为所有方块添加爆炸点击事件
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.add('cursor-crosshair', 'hover:bg-red-100');
                
                // 添加临时点击事件
                const handleBoomClick = function() {
                    const row = parseInt(tile.dataset.row);
                    const col = parseInt(tile.dataset.col);
                    
                    // 移除所有临时事件和样式
                    tiles.forEach(t => {
                        t.classList.remove('cursor-crosshair', 'hover:bg-red-100');
                        t.removeEventListener('click', handleBoomClick);
                    });
                    
                    // 执行爆炸
                    executeBoom(row, col);
                };
                
                tile.addEventListener('click', handleBoomClick, { once: true });
            });
        }

        // 执行爆炸
        function executeBoom(row, col) {
            const matches = [];
            
            // 爆炸范围：3x3
            for (let r = Math.max(0, row - 1); r <= Math.min(gameConfig.gridSize - 1, row + 1); r++) {
                for (let c = Math.max(0, col - 1); c <= Math.min(gameConfig.gridSize - 1, col + 1); c++) {
                    matches.push({ row: r, col: c, type: 'boom' });
                }
            }
            
            // 处理爆炸消除
            processMatches(matches);
            
            // 减少一步
            gameState.remainingMoves--;
            updateRemainingMoves();
            
            // 检查游戏状态
            checkGameStatus();
        }

        // Telegram登录
        function telegramLogin() {
            // 实际应用中应该使用Telegram登录API
            alert('将跳转到Telegram进行登录授权...');
            
            // 模拟登录成功
            setTimeout(() => {
                loginModal.classList.add('hidden');
                alert('登录成功！');
                // 登录成功后加载用户数据
                loadUserData();
            }, 1000);
        }

        // 事件监听
        retryBtn.addEventListener('click', initGame);
        nextLevelBtn.addEventListener('click', nextLevel);
        userBtn.addEventListener('click', () => {
            loginModal.classList.remove('hidden');
        });
        closeLoginBtn.addEventListener('click', () => {
            loginModal.classList.add('hidden');
        });
        telegramLoginBtn.addEventListener('click', telegramLogin);
        
        // 道具按钮事件
        propBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const propType = btn.dataset.prop;
                useProp(propType);
            });
        });

        // 添加动画样式
        const style = document.createElement('style');
        style.textContent = `
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                25% { transform: translateX(-5px); }
                75% { transform: translateX(5px); }
            }
            .animate-shake {
                animation: shake 0.5s ease-in-out;
            }
        `;
        document.head.appendChild(style);

        // 初始化
        window.addEventListener('DOMContentLoaded', () => {
            // 检查本地存储的最大关卡
            const savedMaxLevel = localStorage.getItem('maxLevel');
            if (savedMaxLevel) {
                gameConfig.currentLevel = parseInt(savedMaxLevel);
            }
            
            // 设置关卡目标
            gameConfig.targetScore = 500 + (gameConfig.currentLevel - 1) * 100;
            
            // 加载用户数据
            loadUserData().then(() => {
                // 初始化游戏
                initGame();
            });
        });
    </script>
</body>
</html>
