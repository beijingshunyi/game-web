<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>万花币消消乐</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
    // 配置Tailwind
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#8A5CF7', // 主紫色
            secondary: '#EC4899', // 辅助粉色
            accent: '#F59E0B', // 强调色橙色
            dark: '#1F2937',
            light: '#F9FAFB'
          },
          fontFamily: {
            game: ['"Nunito"', '"Comic Sans MS"', 'sans-serif']
          },
          animation: {
            'pop': 'pop 0.3s ease-out',
            'shine': 'shine 0.5s ease-in-out',
            'float': 'float 2s infinite ease-in-out',
            'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
          },
          keyframes: {
            pop: {
              '0%, 100%': { transform: 'scale(1)' },
              '50%': { transform: 'scale(1.1)' },
            },
            shine: {
              '0%': { opacity: 0 },
              '50%': { opacity: 1 },
              '100%': { opacity: 0 },
            },
            float: {
              '0%, 100%': { transform: 'translateY(0)' },
              '50%': { transform: 'translateY(-10px)' },
            }
          }
        }
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .game-shadow {
        box-shadow: 0 10px 25px -5px rgba(138, 92, 247, 0.1), 0 8px 10px -6px rgba(138, 92, 247, 0.1);
      }
      .tile-shadow {
        box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.1);
      }
      .btn-effect {
        transition: all 0.2s ease;
      }
      .btn-effect:hover {
        transform: translateY(-2px);
      }
      .btn-effect:active {
        transform: translateY(0);
      }
      .text-shadow {
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .bg-gradient-game {
        background: linear-gradient(135deg, #F9FAFB 0%, #F3F4F6 100%);
      }
      .glass-effect {
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(10px);
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
</head>
<body class="bg-gradient-game min-h-screen font-game text-dark overflow-x-hidden">
  <!-- Telegram Web App初始化 -->
  <script>
    const tg = window.Telegram.WebApp;
    tg.ready();
    tg.expand();
    
    // 全局状态管理
    const gameState = {
      user: null,
      balance: 0,
      currentLevel: 1,
      totalScore: 0,
      gamePlays: null,
      isPlaying: false,
      gameBoard: [],
      score: 0,
      moves: 0,
      targetScore: 0,
      movesAllowed: 0,
      levelData: null,
      leaderboard: [],
      selectedTile: null,
      comboCount: 0,
      comboMultiplier: 1,
      gameType: 'score', // score, collect, eliminate, boss
      gameTarget: {},
      timeLimit: null,
      timeRemaining: 0,
      timeInterval: null,
     道具: {
        shuffle: 0,
        bomb: 0,
        addSteps: 0,
        skipObstacle: 0
      },
      skin: 'default',
      background: 'default'
    };
    
    // API基础URL
    const API_BASE_URL = 'https://wanhua-game.bingkuijing.workers.dev/api';
    
    // 工具函数 - 发起API请求
    async function apiRequest(endpoint, method = 'GET', data = null) {
      try {
        const url = `${API_BASE_URL}/${endpoint}`;
        const options = { method, headers: { 'Content-Type': 'application/json' } };
        
        if (data) options.body = JSON.stringify(data);
        
        const response = await fetch(url, options);
        const result = await response.json();
        
        if (!response.ok) throw new Error(result.error || '请求失败');
        
        return result;
      } catch (error) {
        console.error('API请求错误:', error);
        showToast(error.message, 'error');
        throw error;
      }
    }
    
    // 显示提示信息
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `fixed bottom-20 left-1/2 transform -translate-x-1/2 px-4 py-3 rounded-lg z-50 text-white font-medium shadow-lg transition-all duration-300 ${
        type === 'error' ? 'bg-red-500' : 
        type === 'success' ? 'bg-green-500' : 
        type === 'warning' ? 'bg-yellow-500' : 'bg-primary'
      }`;
      toast.textContent = message;
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.classList.add('opacity-0', 'translate-y-4');
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }
    
    // 显示特效文本
    function showFloatingText(text, x, y, color = 'primary') {
      const floatText = document.createElement('div');
      floatText.className = `absolute font-bold text-lg pointer-events-none z-40 transition-all duration-700 transform translate-y-0 opacity-100 ${
        color === 'primary' ? 'text-primary' : 
        color === 'secondary' ? 'text-secondary' : 
        color === 'accent' ? 'text-accent' : 'text-green-500'
      }`;
      floatText.style.left = `${x}px`;
      floatText.style.top = `${y}px`;
      floatText.textContent = text;
      document.getElementById('game-container').appendChild(floatText);
      
      setTimeout(() => {
        floatText.classList.add('opacity-0', 'translate-y-[-20px]');
        setTimeout(() => floatText.remove(), 700);
      }, 100);
    }
    
    // 页面导航
    function navigateTo(pageId) {
      document.querySelectorAll('.page').forEach(page => {
        page.classList.add('hidden');
      });
      document.getElementById(pageId).classList.remove('hidden');
      
      // 特殊页面处理
      if (pageId === 'game-page' && !gameState.isPlaying) {
        startGame(gameState.currentLevel);
      } else if (pageId === 'leaderboard-page') {
        loadLeaderboard();
      } else if (pageId === 'profile-page') {
        loadProfileData();
      } else if (pageId === 'shop-page') {
        loadShopItems();
      }
      
      // 停止计时（如果在游戏外）
      if (pageId !== 'game-page' && gameState.timeInterval) {
        clearInterval(gameState.timeInterval);
        gameState.timeInterval = null;
      }
    }
    
    // 初始化用户
    async function initUser() {
      try {
        // 从URL获取用户信息
        const urlParams = new URLSearchParams(window.location.search);
        const telegramId = urlParams.get('user_id');
        
        if (!telegramId) {
          // 尝试从Telegram Web App获取用户信息
          if (tg.initDataUnsafe?.user) {
            const user = tg.initDataUnsafe.user;
            await apiRequest('login', 'POST', {
              queryId: tg.initDataUnsafe.query_id,
              userId: user.id,
              firstName: user.first_name,
              lastName: user.last_name || '',
              username: user.username || ''
            });
            window.location.search = `user_id=${user.id}&username=${encodeURIComponent(user.username || '')}`;
            return;
          } else {
            navigateTo('login-page');
            return;
          }
        }
        
        // 加载用户数据
        const userData = await apiRequest(`user?telegram_id=${telegramId}`);
        gameState.user = userData.user;
        gameState.balance = userData.balance.万花币_balance;
        gameState.currentLevel = userData.progress.current_level;
        gameState.totalScore = userData.progress.total_score;
        gameState.gamePlays = userData.gamePlays;
        
        // 更新UI
        updateUserInterface();
        
        // 导航到首页
        navigateTo('home-page');
      } catch (error) {
        console.error('初始化用户失败:', error);
        showToast('登录失败，请重试', 'error');
        navigateTo('login-page');
      }
    }
    
    // 更新用户界面
    function updateUserInterface() {
      // 更新余额显示
      document.querySelectorAll('.balance-display').forEach(el => {
        el.textContent = gameState.balance;
      });
      
      // 更新当前关卡
      document.getElementById('current-level-display').textContent = gameState.currentLevel;
      
      // 更新总分数
      document.getElementById('total-score-display').textContent = gameState.totalScore;
      
      // 更新游戏次数
      if (gameState.gamePlays) {
        const remainingFreePlays = 6 - gameState.gamePlays.free_plays_used;
        document.getElementById('remaining-plays').textContent = remainingFreePlays;
      }
      
      // 更新个人资料
      if (gameState.user && document.getElementById('profile-name')) {
        document.getElementById('profile-name').textContent = 
          gameState.user.first_name + (gameState.user.last_name ? ' ' + gameState.user.last_name : '');
        document.getElementById('profile-username').textContent = 
          gameState.user.username ? '@' + gameState.user.username : '未设置用户名';
        document.getElementById('profile-id').textContent = 'ID: ' + gameState.user.telegram_id;
      }
    }
    
    // 处理签到
    async function handleCheckin() {
      try {
        const result = await apiRequest('checkin', 'POST', {
          telegram_id: gameState.user.telegram_id
        });
        
        if (result.success) {
          gameState.balance = result.balance;
          showToast(`签到成功！获得${result.reward}万花币，连续签到${result.streak}天`, 'success');
          
          // 显示签到动画
          const checkinBtn = document.getElementById('checkin-btn');
          checkinBtn.classList.add('animate-pop');
          setTimeout(() => checkinBtn.classList.remove('animate-pop'), 300);
          
          updateUserInterface();
          checkinBtn.disabled = true;
          checkinBtn.textContent = '今日已签到';
          checkinBtn.classList.remove('bg-accent', 'hover:bg-accent/80');
          checkinBtn.classList.add('bg-gray-300', 'cursor-not-allowed');
        } else {
          showToast(result.message);
        }
      } catch (error) {
        console.error('签到失败:', error);
      }
    }
    
    // 检查是否可以玩游戏
    async function checkCanPlayGame() {
      try {
        const result = await apiRequest(`game-plays?telegram_id=${gameState.user.telegram_id}`);
        return result.canPlay;
      } catch (error) {
        console.error('检查游戏次数失败:', error);
        return false;
      }
    }
    
    // 记录游戏次数
    async function recordGamePlay(type) {
      try {
        const result = await apiRequest('record-play', 'POST', {
          telegram_id: gameState.user.telegram_id,
          type
        });
        
        gameState.gamePlays = result.gamePlays;
        updateUserInterface();
        return true;
      } catch (error) {
        console.error('记录游戏次数失败:', error);
        return false;
      }
    }
    
    // 增加游戏次数 (通过广告或分享)
    async function addGamePlays(type) {
      try {
        if (type === 'ad') {
          // 显示广告逻辑
          showToast('广告播放中...');
          // 模拟广告播放
          setTimeout(async () => {
            const result = await apiRequest('add-plays', 'POST', {
              telegram_id: gameState.user.telegram_id,
              type
            });
            
            if (result.success) {
              gameState.gamePlays = result.gamePlays;
              updateUserInterface();
              showToast(`获得2次游戏机会！剩余次数: ${6 - result.gamePlays.free_plays_used}`, 'success');
            } else {
              showToast(result.message, 'warning');
            }
          }, 3000);
        } else if (type === 'share') {
          // 分享逻辑
          if (tg.ShareButton) {
            tg.ShareButton.show();
            tg.onEvent('shareCompleted', async () => {
              const result = await apiRequest('add-plays', 'POST', {
                telegram_id: gameState.user.telegram_id,
                type
              });
              
              if (result.success) {
                gameState.gamePlays = result.gamePlays;
                updateUserInterface();
                showToast(`获得2次游戏机会！剩余次数: ${6 - result.gamePlays.free_plays_used}`, 'success');
              } else {
                showToast(result.message, 'warning');
              }
            });
          } else {
            showToast('分享功能暂不可用');
          }
        }
      } catch (error) {
        console.error('增加游戏次数失败:', error);
      }
    }
    
    // 加载关卡数据
    async function loadLevelData(levelNumber) {
      try {
        const levelData = await apiRequest(`level?level=${levelNumber}`);
        gameState.levelData = levelData;
        return levelData;
      } catch (error) {
        console.error('加载关卡数据失败:', error);
        showToast('加载关卡失败，请重试', 'error');
        return null;
      }
    }
    
    // 初始化游戏板
    function initializeGameBoard(levelNumber) {
      // 根据关卡决定棋盘大小
      const size = levelNumber >= 20 ? 6 : 5;
      const board = [];
      const tileTypes = ['flower', 'star', 'moon', 'sun', 'gem', 'bell'];
      
      // 获取关卡障碍物配置
      const obstacles = gameState.levelData?.obstacles || {type: "none"};
      
      for (let i = 0; i < size; i++) {
        const row = [];
        for (let j = 0; j < size; j++) {
          // 确保不会初始形成三个相同的连线
          let type;
          do {
            type = tileTypes[Math.floor(Math.random() * tileTypes.length)];
          } while (
            // 检查水平方向
            (j >= 2 && row[j-1].type === type && row[j-2].type === type) ||
            // 检查垂直方向
            (i >= 2 && board[i-1][j].type === type && board[i-2][j].type === type)
          );
          
          // 添加障碍物
          let obstacle = null;
          const rand = Math.random();
          
          // 根据关卡类型和难度设置不同障碍物
          if (levelNumber >= 11) {
            // 基础关卡障碍物
            if (obstacles.type === 'ice' && rand < 0.15) {
              obstacle = {type: 'ice', hits: 1};
            } else if (obstacles.type === 'chain' && rand < 0.1) {
              obstacle = {type: 'chain', hits: 2};
            }
          }
          
          if (levelNumber >= 21) {
            // 进阶关卡障碍物
            if (obstacles.type === 'frozen' && rand < 0.1) {
              obstacle = {type: 'frozen', hits: 1, locked: true};
            } else if (obstacles.type === 'box' && rand < 0.08) {
              obstacle = {type: 'box', hits: 3};
            }
          }
          
          if (levelNumber >= 41 && rand < 0.05) {
            // 挑战关卡BOSS元素
            obstacle = {type: 'boss', hits: 3};
          }
          
          // 限时炸弹（挑战关卡）
          if (levelNumber >= 41 && rand < 0.07) {
            obstacle = {type: 'bomb', timer: 5};
          }
          
          row.push({
            id: `${i}-${j}`,
            type,
            obstacle,
            x: j,
            y: i,
            matched: false,
            selected: false,
            special: null // normal, line, bomb, cross
          });
        }
        board.push(row);
      }
      
      // 检查是否有可消除的组合，如果没有则洗牌
      if (!hasPossibleMatches(board)) {
        shuffleBoard(board);
      }
      
      return board;
    }
    
    // 检查是否有可消除的组合
    function hasPossibleMatches(board) {
      const size = board.length;
      
      // 检查水平方向可能的匹配
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size - 2; j++) {
          const current = board[i][j];
          const next1 = board[i][j+1];
          const next2 = board[i][j+2];
          
          if (current.obstacle?.type === 'boss' || 
              next1.obstacle?.type === 'boss' || 
              next2.obstacle?.type === 'boss') {
            continue;
          }
          
          if (current.type === next1.type || 
              current.type === next2.type || 
              next1.type === next2.type) {
            return true;
          }
        }
      }
      
      // 检查垂直方向可能的匹配
      for (let j = 0; j < size; j++) {
        for (let i = 0; i < size - 2; i++) {
          const current = board[i][j];
          const next1 = board[i+1][j];
          const next2 = board[i+2][j];
          
          if (current.obstacle?.type === 'boss' || 
              next1.obstacle?.type === 'boss' || 
              next2.obstacle?.type === 'boss') {
            continue;
          }
          
          if (current.type === next1.type || 
              current.type === next2.type || 
              next1.type === next2.type) {
            return true;
          }
        }
      }
      
      return false;
    }
    
    // 洗牌棋盘
    function shuffleBoard(board) {
      const size = board.length;
      const tileTypes = ['flower', 'star', 'moon', 'sun', 'gem', 'bell'];
      
      // 保留障碍物位置，只重新分配元素类型
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          const obstacle = board[i][j].obstacle;
          board[i][j] = {
            ...board[i][j],
            type: tileTypes[Math.floor(Math.random() * tileTypes.length)],
            matched: false,
            selected: false,
            special: null
          };
        }
      }
      
      // 确保洗牌后有可匹配的组合
      if (!hasPossibleMatches(board)) {
        shuffleBoard(board);
      }
      
      return board;
    }
    
    // 渲染游戏板
    function renderGameBoard() {
      const gameBoardElement = document.getElementById('game-board');
      gameBoardElement.innerHTML = '';
      
      // 设置网格尺寸
      const size = gameState.gameBoard.length;
      gameBoardElement.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
      
      gameState.gameBoard.forEach((row, rowIndex) => {
        row.forEach((tile, colIndex) => {
          const tileElement = document.createElement('div');
          tileElement.id = `tile-${rowIndex}-${colIndex}`;
          tileElement.className = `aspect-square flex items-center justify-center rounded-lg tile-shadow transition-all duration-300 ${
            tile.selected ? 'ring-4 ring-accent scale-110 z-10' : ''
          }`;
          
          // 设置背景色和图标
          switch (tile.type) {
            case 'flower': 
              tileElement.classList.add('bg-pink-100', 'text-pink-600');
              tileElement.innerHTML = '<i class="fa fa-pagelines text-2xl"></i>';
              break;
            case 'star': 
              tileElement.classList.add('bg-yellow-100', 'text-yellow-500');
              tileElement.innerHTML = '<i class="fa fa-star text-2xl"></i>';
              break;
            case 'moon': 
              tileElement.classList.add('bg-indigo-100', 'text-indigo-600');
              tileElement.innerHTML = '<i class="fa fa-moon-o text-2xl"></i>';
              break;
            case 'sun': 
              tileElement.classList.add('bg-orange-100', 'text-orange-500');
              tileElement.innerHTML = '<i class="fa fa-sun-o text-2xl"></i>';
              break;
            case 'gem': 
              tileElement.classList.add('bg-blue-100', 'text-blue-600');
              tileElement.innerHTML = '<i class="fa fa-diamond text-2xl"></i>';
              break;
            case 'bell': 
              tileElement.classList.add('bg-purple-100', 'text-purple-600');
              tileElement.innerHTML = '<i class="fa fa-bell text-2xl"></i>';
              break;
          }
          
          // 特殊元素标记
          if (tile.special === 'line') {
            tileElement.classList.add('border-2', 'border-red-500');
            tileElement.innerHTML += '<div class="absolute top-1 right-1 bg-red-500 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">L</div>';
          } else if (tile.special === 'bomb') {
            tileElement.classList.add('border-2', 'border-orange-500');
            tileElement.innerHTML += '<div class="absolute top-1 right-1 bg-orange-500 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">B</div>';
          } else if (tile.special === 'cross') {
            tileElement.classList.add('border-2', 'border-green-500');
            tileElement.innerHTML += '<div class="absolute top-1 right-1 bg-green-500 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">X</div>';
          }
          
          // 添加障碍物
          if (tile.obstacle) {
            const obstacleDiv = document.createElement('div');
            obstacleDiv.className = 'absolute inset-0 flex items-center justify-center bg-black/20 rounded-lg';
            
            switch (tile.obstacle.type) {
              case 'ice':
                obstacleDiv.innerHTML = '<i class="fa fa-snowflake-o text-blue-700 text-xl"></i>';
                if (tile.obstacle.hits > 1) {
                  obstacleDiv.innerHTML += `<div class="absolute bottom-1 right-1 bg-blue-700 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">${tile.obstacle.hits}</div>`;
                }
                break;
              case 'chain':
                obstacleDiv.innerHTML = '<i class="fa fa-link text-gray-700 text-xl"></i>';
                if (tile.obstacle.hits > 1) {
                  obstacleDiv.innerHTML += `<div class="absolute bottom-1 right-1 bg-gray-700 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">${tile.obstacle.hits}</div>`;
                }
                break;
              case 'frozen':
                obstacleDiv.innerHTML = '<i class="fa fa-snowflake-o text-cyan-700 text-xl"></i>';
                obstacleDiv.innerHTML += '<i class="fa fa-lock text-cyan-700 absolute top-1 right-1"></i>';
                break;
              case 'box':
                obstacleDiv.innerHTML = '<i class="fa fa-cube text-gray-600 text-xl"></i>';
                obstacleDiv.innerHTML += `<div class="absolute bottom-1 right-1 bg-gray-600 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">${tile.obstacle.hits}</div>`;
                break;
              case 'boss':
                obstacleDiv.className = 'absolute inset-0 flex items-center justify-center bg-purple-900/30 rounded-lg';
                obstacleDiv.innerHTML = '<i class="fa fa-dragon text-purple-800 text-2xl"></i>';
                obstacleDiv.innerHTML += `<div class="absolute bottom-1 right-1 bg-purple-800 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">${tile.obstacle.hits}</div>`;
                break;
              case 'bomb':
                obstacleDiv.className = 'absolute inset-0 flex items-center justify-center bg-red-900/30 rounded-lg';
                obstacleDiv.innerHTML = '<i class="fa fa-bomb text-red-700 text-xl"></i>';
                obstacleDiv.innerHTML += `<div class="absolute bottom-1 right-1 bg-red-700 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">${tile.obstacle.timer}</div>`;
                break;
            }
            
            tileElement.appendChild(obstacleDiv);
          }
          
          // 添加点击事件
          tileElement.addEventListener('click', () => handleTileClick(rowIndex, colIndex));
          
          // 添加悬停效果
          tileElement.addEventListener('mouseenter', () => {
            if (!tile.selected) tileElement.classList.add('scale-105');
          });
          tileElement.addEventListener('mouseleave', () => {
            if (!tile.selected) tileElement.classList.remove('scale-105');
          });
          
          // 添加触摸滑动支持
          let touchStartX = 0;
          let touchStartY = 0;
          
          tileElement.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
          }, { passive: false });
          
          tileElement.addEventListener('touchend', (e) => {
            if (!gameState.selectedTile) {
              handleTileClick(rowIndex, colIndex);
              return;
            }
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const diffX = touchEndX - touchStartX;
            const diffY = touchEndY - touchStartY;
            
            // 确定滑动方向
            if (Math.abs(diffX) > Math.abs(diffY)) {
              // 水平滑动
              if (diffX > 50 && colIndex < size - 1) {
                // 向右滑动
                handleTileClick(rowIndex, colIndex + 1);
              } else if (diffX < -50 && colIndex > 0) {
                // 向左滑动
                handleTileClick(rowIndex, colIndex - 1);
              } else {
                handleTileClick(rowIndex, colIndex);
              }
            } else {
              // 垂直滑动
              if (diffY > 50 && rowIndex < size - 1) {
                // 向下滑动
                handleTileClick(rowIndex + 1, colIndex);
              } else if (diffY < -50 && rowIndex > 0) {
                // 向上滑动
                handleTileClick(rowIndex - 1, colIndex);
              } else {
                handleTileClick(rowIndex, colIndex);
              }
            }
            
            e.preventDefault();
          }, { passive: false });
          
          gameBoardElement.appendChild(tileElement);
        });
      });
      
      // 更新分数和步数显示
      document.getElementById('game-score').textContent = gameState.score;
      document.getElementById('target-score').textContent = gameState.targetScore;
      document.getElementById('remaining-moves').textContent = gameState.movesAllowed - gameState.moves;
      
      // 更新关卡目标显示
      updateLevelObjectiveDisplay();
      
      // 更新时间显示（如果有时间限制）
      if (gameState.timeLimit) {
        const minutes = Math.floor(gameState.timeRemaining / 60);
        const seconds = gameState.timeRemaining % 60;
        document.getElementById('time-remaining').textContent = 
          `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      
      // 更新道具数量
      document.getElementById('shuffle-count').textContent = gameState.道具.shuffle;
      document.getElementById('bomb-count').textContent = gameState.道具.bomb;
      document.getElementById('steps-count').textContent = gameState.道具.addSteps;
    }
    
    // 更新关卡目标显示
    function updateLevelObjectiveDisplay() {
      const objectiveElement = document.getElementById('level-objective');
      
      if (!gameState.levelData) return;
      
      switch (gameState.gameType) {
        case 'score':
          objectiveElement.innerHTML = `
            <div class="flex items-center">
              <i class="fa fa-trophy text-accent mr-2"></i>
              <span>累计得分 ${gameState.score}/${gameState.targetScore}</span>
            </div>
          `;
          break;
        case 'collect':
          const collected = gameState.gameTarget.collected || 0;
          objectiveElement.innerHTML = `
            <div class="flex items-center">
              <i class="fa fa-pagelines text-pink-600 mr-2"></i>
              <span>收集花朵 ${collected}/${gameState.gameTarget.required}</span>
            </div>
          `;
          break;
        case 'eliminate':
          const eliminated = gameState.gameTarget.eliminated || 0;
          objectiveElement.innerHTML = `
            <div class="flex items-center">
              <i class="fa fa-link text-gray-600 mr-2"></i>
              <span>消除锁链 ${eliminated}/${gameState.gameTarget.required}</span>
            </div>
          `;
          break;
        case 'boss':
          const bossesEliminated = gameState.gameTarget.bossesEliminated || 0;
          objectiveElement.innerHTML = `
            <div class="flex items-center">
              <i class="fa fa-dragon text-purple-800 mr-2"></i>
              <span>击败BOSS ${bossesEliminated}/${gameState.gameTarget.required}</span>
            </div>
          `;
          break;
      }
    }
    
    // 处理方块点击
    function handleTileClick(row, col) {
      if (!gameState.isPlaying) return;
      
      const clickedTile = gameState.gameBoard[row][col];
      
      // 如果点击了有锁定障碍物的方块，无法选中
      if (clickedTile.obstacle?.locked) {
        showToast('需要先解锁这个方块！', 'warning');
        return;
      }
      
      // 检查是否有已选中的方块
      if (gameState.selectedTile) {
        const [selectedRow, selectedCol] = gameState.selectedTile;
        
        // 如果点击的是已选中的方块，取消选择
        if (selectedRow === row && selectedCol === col) {
          deselectAllTiles();
          renderGameBoard();
          return;
        }
        
        // 检查是否相邻
        if (isAdjacent(selectedRow, selectedCol, row, col)) {
          // 交换方块
          swapTiles(selectedRow, selectedCol, row, col);
          
          // 检查是否有匹配
          const matches = findMatches();
          
          if (matches.length > 0) {
            // 有匹配，处理匹配
            processMatches(matches);
            gameState.moves++;
            
            // 处理炸弹计时器
            updateBombTimers();
          } else {
            // 无匹配，交换回来
            setTimeout(() => {
              swapTiles(row, col, selectedRow, selectedCol);
              renderGameBoard();
            }, 300);
          }
          
          // 取消选择
          deselectAllTiles();
        } else {
          // 不相邻，取消之前的选择，选择新的
          deselectAllTiles();
          clickedTile.selected = true;
          gameState.selectedTile = [row, col];
          renderGameBoard();
        }
      } else {
        // 没有已选中的，选中当前方块
        clickedTile.selected = true;
        gameState.selectedTile = [row, col];
        renderGameBoard();
      }
    }
    
    // 取消所有选择
    function deselectAllTiles() {
      gameState.gameBoard.forEach(row => {
        row.forEach(tile => {
          tile.selected = false;
        });
      });
      gameState.selectedTile = null;
    }
    
    // 检查是否相邻
    function isAdjacent(row1, col1, row2, col2) {
      return (
        (Math.abs(row1 - row2) === 1 && col1 === col2) ||
        (Math.abs(col1 - col2) === 1 && row1 === row2)
      );
    }
    
    // 交换方块
    function swapTiles(row1, col1, row2, col2) {
      // 获取方块DOM元素用于动画
      const tile1 = document.getElementById(`tile-${row1}-${col1}`);
      const tile2 = document.getElementById(`tile-${row2}-${col2}`);
      
      if (tile1 && tile2) {
        // 添加交换动画
        const rect1 = tile1.getBoundingClientRect();
        const rect2 = tile2.getBoundingClientRect();
        
        tile1.style.position = 'absolute';
        tile1.style.left = `${rect1.left}px`;
        tile1.style.top = `${rect1.top}px`;
        tile1.style.width = `${rect1.width}px`;
        tile1.style.height = `${rect1.height}px`;
        
        tile2.style.position = 'absolute';
        tile2.style.left = `${rect2.left}px`;
        tile2.style.top = `${rect2.top}px`;
        tile2.style.width = `${rect2.width}px`;
        tile2.style.height = `${rect2.height}px`;
        
        // 交换位置
        setTimeout(() => {
          tile1.style.transform = `translate(${rect2.left - rect1.left}px, ${rect2.top - rect1.top}px)`;
          tile2.style.transform = `translate(${rect1.left - rect2.left}px, ${rect1.top - rect2.top}px)`;
        }, 50);
      }
      
      // 实际交换数据
      const temp = gameState.gameBoard[row1][col1];
      gameState.gameBoard[row1][col1] = gameState.gameBoard[row2][col2];
      gameState.gameBoard[row2][col2] = temp;
      
      // 更新位置信息
      gameState.gameBoard[row1][col1].x = col1;
      gameState.gameBoard[row1][col1].y = row1;
      gameState.gameBoard[row2][col2].x = col2;
      gameState.gameBoard[row2][col2].y = row2;
      
      // 重新渲染
      setTimeout(() => {
        renderGameBoard();
      }, 300);
    }
    
    // 查找匹配
    function findMatches() {
      const matches = [];
      const size = gameState.gameBoard.length;
      
      // 先清除之前的匹配标记
      gameState.gameBoard.forEach(row => {
        row.forEach(tile => {
          tile.matched = false;
        });
      });
      
      // 检查水平匹配
      for (let i = 0; i < size; i++) {
        let j = 0;
        while (j < size - 2) {
          const current = gameState.gameBoard[i][j];
          const next1 = gameState.gameBoard[i][j+1];
          const next2 = gameState.gameBoard[i][j+2];
          
          // 跳过有锁定障碍物的方块
          if (current.obstacle?.locked || next1.obstacle?.locked || next2.obstacle?.locked) {
            j++;
            continue;
          }
          
          if (current.type === next1.type && current.type === next2.type) {
            const matchLength = findMatchLength(i, j, 0, 1);
            const match = [];
            
            for (let k = 0; k < matchLength; k++) {
              match.push({ row: i, col: j + k });
              gameState.gameBoard[i][j + k].matched = true;
            }
            
            matches.push(match);
            j += matchLength;
          } else {
            j++;
          }
        }
      }
      
      // 检查垂直匹配
      for (let j = 0; j < size; j++) {
        let i = 0;
        while (i < size - 2) {
          const current = gameState.gameBoard[i][j];
          const next1 = gameState.gameBoard[i+1][j];
          const next2 = gameState.gameBoard[i+2][j];
          
          // 跳过有锁定障碍物的方块
          if (current.obstacle?.locked || next1.obstacle?.locked || next2.obstacle?.locked) {
            i++;
            continue;
          }
          
          if (current.type === next1.type && current.type === next2.type) {
            const matchLength = findMatchLength(i, j, 1, 0);
            const match = [];
            
            for (let k = 0; k < matchLength; k++) {
              match.push({ row: i + k, col: j });
              gameState.gameBoard[i + k][j].matched = true;
            }
            
            matches.push(match);
            i += matchLength;
          } else {
            i++;
          }
        }
      }
      
      // 检查L型和T型匹配（十字特效）
      const crossMatches = findCrossMatches();
      crossMatches.forEach(match => {
        matches.push(match);
        match.forEach(pos => {
          gameState.gameBoard[pos.row][pos.col].matched = true;
        });
      });
      
      return matches;
    }
    
    // 查找匹配长度
    function findMatchLength(startRow, startCol, rowDir, colDir) {
      const type = gameState.gameBoard[startRow][startCol].type;
      let length = 1;
      
      let currentRow = startRow + rowDir;
      let currentCol = startCol + colDir;
      
      while (
        currentRow < gameState.gameBoard.length &&
        currentCol < gameState.gameBoard[0].length &&
        !gameState.gameBoard[currentRow][currentCol].obstacle?.locked &&
        gameState.gameBoard[currentRow][currentCol].type === type
      ) {
        length++;
        currentRow += rowDir;
        currentCol += colDir;
      }
      
      return length;
    }
    
    // 查找L型和T型匹配（十字特效）
    function findCrossMatches() {
      const matches = [];
      const size = gameState.gameBoard.length;
      
      for (let i = 1; i < size - 1; i++) {
        for (let j = 1; j < size - 1; j++) {
          const center = gameState.gameBoard[i][j];
          
          // 跳过有锁定障碍物的方块
          if (center.obstacle?.locked) continue;
          
          // 检查T型匹配
          // 水平+上
          if (
            gameState.gameBoard[i][j-1].type === center.type &&
            gameState.gameBoard[i][j+1].type === center.type &&
            gameState.gameBoard[i-1][j].type === center.type &&
            !gameState.gameBoard[i][j-1].obstacle?.locked &&
            !gameState.gameBoard[i][j+1].obstacle?.locked &&
            !gameState.gameBoard[i-1][j].obstacle?.locked
          ) {
            matches.push([
              {row: i, col: j-1}, {row: i, col: j}, {row: i, col: j+1},
              {row: i-1, col: j}
            ]);
          }
          
          // 水平+下
          if (
            gameState.gameBoard[i][j-1].type === center.type &&
            gameState.gameBoard[i][j+1].type === center.type &&
            gameState.gameBoard[i+1][j].type === center.type &&
            !gameState.gameBoard[i][j-1].obstacle?.locked &&
            !gameState.gameBoard[i][j+1].obstacle?.locked &&
            !gameState.gameBoard[i+1][j].obstacle?.locked
          ) {
            matches.push([
              {row: i, col: j-1}, {row: i, col: j}, {row: i, col: j+1},
              {row: i+1, col: j}
            ]);
          }
          
          // 垂直+左
          if (
            gameState.gameBoard[i-1][j].type === center.type &&
            gameState.gameBoard[i+1][j].type === center.type &&
            gameState.gameBoard[i][j-1].type === center.type &&
            !gameState.gameBoard[i-1][j].obstacle?.locked &&
            !gameState.gameBoard[i+1][j].obstacle?.locked &&
            !gameState.gameBoard[i][j-1].obstacle?.locked
          ) {
            matches.push([
              {row: i-1, col: j}, {row: i, col: j}, {row: i+1, col: j},
              {row: i, col: j-1}
            ]);
          }
          
          // 垂直+右
          if (
            gameState.gameBoard[i-1][j].type === center.type &&
            gameState.gameBoard[i+1][j].type === center.type &&
            gameState.gameBoard[i][j+1].type === center.type &&
            !gameState.gameBoard[i-1][j].obstacle?.locked &&
            !gameState.gameBoard[i+1][j].obstacle?.locked &&
            !gameState.gameBoard[i][j+1].obstacle?.locked
          ) {
            matches.push([
              {row: i-1, col: j}, {row: i, col: j}, {row: i+1, col: j},
              {row: i, col: j+1}
            ]);
          }
        }
      }
      
      return matches;
    }
    
    // 处理匹配
    function processMatches(matches) {
      if (matches.length === 0) {
        // 检查游戏是否结束
        checkGameEnd();
        return;
      }
      
      // 增加连击计数
      gameState.comboCount++;
      if (gameState.comboCount >= 3) {
        gameState.comboMultiplier = Math.min(2, 1 + Math.floor((gameState.comboCount - 3) / 5));
        showFloatingText(`连击 x${gameState.comboMultiplier}`, 
          window.innerWidth / 2, 100, 'accent');
      }
      
      // 标记匹配的方块并计算分数
      let totalPointsThisTurn = 0;
      matches.forEach(match => {
        match.forEach(position => {
          const tile = gameState.gameBoard[position.row][position.col];
          
          // 根据匹配长度计算分数
          let points = 10 * gameState.comboMultiplier;
          if (match.length >= 4) points = 20 * gameState.comboMultiplier;
          if (match.length >= 5) points = 50 * gameState.comboMultiplier;
          
          // 障碍物加分
          if (tile.obstacle) {
            switch (tile.obstacle.type) {
              case 'ice': points += 5 * gameState.comboMultiplier; break;
              case 'chain': points += 10 * gameState.comboMultiplier; break;
              case 'frozen': points += 15 * gameState.comboMultiplier; break;
              case 'box': points += 20 * gameState.comboMultiplier; break;
              case 'boss': points += 50 * gameState.comboMultiplier; break;
              case 'bomb': points += 25 * gameState.comboMultiplier; break;
            }
          }
          
          totalPointsThisTurn += points;
          gameState.score += points;
          
          // 记录特效生成
          if (match.length >= 4) {
            // 4连生成直线特效
            if (match[0].row === match[1].row) {
              // 水平匹配
              tile.special = 'line'; // 水平直线
            } else {
              tile.special = 'line'; // 垂直直线
            }
          }
          
          if (match.length >= 5) {
            // 5连生成爆炸特效
            tile.special = 'bomb';
          }
          
          if (match.length === 4 && (match.length === 4 && 
              (match[0].row !== match[1].row || match[0].col !== match[1].col))) {
            // L/T型生成十字特效
            tile.special = 'cross';
          }
          
          // 关卡目标处理
          if (gameState.gameType === 'collect' && tile.type === 'flower') {
            gameState.gameTarget.collected = (gameState.gameTarget.collected || 0) + 1;
          }
          
          if (gameState.gameType === 'eliminate' && tile.obstacle?.type === 'chain') {
            gameState.gameTarget.eliminated = (gameState.gameTarget.eliminated || 0) + 1;
          }
        });
      });
      
      // 显示得分动画
      const boardRect = document.getElementById('game-board').getBoundingClientRect();
      showFloatingText(`+${totalPointsThisTurn}`, 
        boardRect.left + boardRect.width / 2, 
        boardRect.top + boardRect.height / 2, 'secondary');
      
      // 重新渲染以显示匹配的方块
      renderGameBoard();
      
      // 添加消除动画
      matches.forEach(match => {
        match.forEach(position => {
          const tileElement = document.getElementById(`tile-${position.row}-${position.col}`);
          if (tileElement) {
            tileElement.classList.add('scale-0', 'opacity-0', 'transition-all', 'duration-300');
          }
        });
      });
      
      // 移除匹配的方块并填充新方块
      setTimeout(() => {
        removeMatchedTiles();
        fillEmptySpaces();
        
        // 检查是否有新的匹配
        setTimeout(() => {
          const newMatches = findMatches();
          processMatches(newMatches);
        }, 500);
      }, 300);
    }
    
    // 更新炸弹计时器
    function updateBombTimers() {
      const size = gameState.gameBoard.length;
      let bombExploded = false;
      
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          const tile = gameState.gameBoard[i][j];
          
          if (tile.obstacle?.type === 'bomb') {
            tile.obstacle.timer--;
            
            if (tile.obstacle.timer <= 0) {
              // 炸弹爆炸
              bombExploded = true;
              explodeBomb(i, j);
            }
          }
        }
      }
      
      if (bombExploded) {
        renderGameBoard();
      }
    }
    
    // 炸弹爆炸效果
    function explodeBomb(row, col) {
      const size = gameState.gameBoard.length;
      
      // 炸弹爆炸会消除3x3范围内的元素
      for (let i = Math.max(0, row - 1); i <= Math.min(size - 1, row + 1); i++) {
        for (let j = Math.max(0, col - 1); j <= Math.min(size - 1, col + 1); j++) {
          gameState.gameBoard[i][j].matched = true;
        }
      }
      
      // 扣分
      gameState.score = Math.max(0, gameState.score - 100);
      showFloatingText('-100', 
        document.getElementById(`tile-${row}-${col}`).getBoundingClientRect().left, 
        document.getElementById(`tile-${row}-${col}`).getBoundingClientRect().top, 'error');
      
      // 处理爆炸后的匹配
      setTimeout(() => {
        removeMatchedTiles();
        fillEmptySpaces();
        renderGameBoard();
      }, 300);
    }
    
    // 移除匹配的方块
    function removeMatchedTiles() {
      const size = gameState.gameBoard.length;
      
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          if (gameState.gameBoard[i][j].matched) {
            const tile = gameState.gameBoard[i][j];
            
            // 处理障碍物
            if (tile.obstacle) {
              switch (tile.obstacle.type) {
                case 'ice':
                  // 冰块障碍物减少生命值
                  tile.obstacle.hits--;
                  if (tile.obstacle.hits <= 0) {
                    // 冰块消除，保留元素
                    tile.obstacle = null;
                    tile.matched = false;
                  } else {
                    // 冰块未消除，不替换元素
                    tile.matched = false;
                  }
                  break;
                  
                case 'chain':
                  // 锁链障碍物减少生命值
                  tile.obstacle.hits--;
                  if (tile.obstacle.hits <= 0) {
                    // 锁链消除，保留元素
                    tile.obstacle = null;
                    tile.matched = false;
                  } else {
                    // 锁链未消除，不替换元素
                    tile.matched = false;
                  }
                  break;
                  
                case 'frozen':
                  // 冻结障碍物被消除后解锁
                  tile.obstacle = null;
                  tile.matched = false;
                  break;
                  
                case 'box':
                  // 箱子障碍物减少生命值
                  tile.obstacle.hits--;
                  if (tile.obstacle.hits <= 0) {
                    // 箱子消除，替换元素
                    gameState.gameBoard[i][j] = null;
                  } else {
                    // 箱子未消除，不替换元素
                    tile.matched = false;
                  }
                  break;
                  
                case 'boss':
                  // BOSS障碍物减少生命值
                  tile.obstacle.hits--;
                  if (tile.obstacle.hits <= 0) {
                    // BOSS被击败，替换元素
                    gameState.gameBoard[i][j] = null;
                    gameState.gameTarget.bossesEliminated = (gameState.gameTarget.bossesEliminated || 0) + 1;
                  } else {
                    // BOSS未被击败，不替换元素
                    tile.matched = false;
                  }
                  break;
                  
                case 'bomb':
                  // 炸弹被消除，不替换元素
                  gameState.gameBoard[i][j] = null;
                  break;
                  
                default:
                  gameState.gameBoard[i][j] = null;
              }
            } else {
              // 普通方块直接替换
              gameState.gameBoard[i][j] = null;
            }
          }
        }
      }
    }
    
    // 创建新方块
    function createNewTile(x, y) {
      const tileTypes = ['flower', 'star', 'moon', 'sun', 'gem', 'bell'];
      const type = tileTypes[Math.floor(Math.random() * tileTypes.length)];
      
      return {
        id: `${y}-${x}`,
        type,
        obstacle: null,
        x,
        y,
        matched: false,
        selected: false,
        special: null
      };
    }
    
    // 填充空白位置
    function fillEmptySpaces() {
      const size = gameState.gameBoard.length;
      
      // 处理每一列
      for (let j = 0; j < size; j++) {
        // 下落现有方块
        for (let i = size - 1; i >= 0; i--) {
          if (gameState.gameBoard[i][j] === null) {
            // 查找上方最近的非空方块
            for (let k = i - 1; k >= 0; k--) {
              if (gameState.gameBoard[k][j] !== null) {
                // 下落方块
                gameState.gameBoard[i][j] = gameState.gameBoard[k][j];
                gameState.gameBoard[k][j] = null;
                gameState.gameBoard[i][j].y = i; // 更新位置
                break;
              }
            }
          }
        }
        
        // 顶部填充新方块
        for (let i = 0; i < size; i++) {
          if (gameState.gameBoard[i][j] === null) {
            gameState.gameBoard[i][j] = createNewTile(j, i);
          }
        }
      }
      
      // 检查是否有可匹配的组合，如果没有则洗牌
      if (!hasPossibleMatches(gameState.gameBoard)) {
        showToast('没有可消除的组合，正在洗牌...', 'info');
        shuffleBoard(gameState.gameBoard);
      }
      
      renderGameBoard();
    }
    
    // 使用道具
    function use道具(type) {
      if (!gameState.isPlaying) return;
      
      switch (type) {
        case 'shuffle':
          if (gameState.道具.shuffle <= 0) {
            showToast('没有洗牌道具了！', 'warning');
            return;
          }
          
          gameState.道具.shuffle--;
          showToast('使用了洗牌道具', 'info');
          shuffleBoard(gameState.gameBoard);
          renderGameBoard();
          break;
          
        case 'bomb':
          if (gameState.道具.bomb <= 0) {
            showToast('没有炸弹道具了！', 'warning');
            return;
          }
          
          showToast('点击要消除的位置', 'info');
          // 进入炸弹选择模式
          const boardElement = document.getElementById('game-board');
          const handleBombClick = function(e) {
            const rect = boardElement.getBoundingClientRect();
            const size = gameState.gameBoard.length;
            const cellSize = rect.width / size;
            
            const col = Math.floor((e.clientX - rect.left) / cellSize);
            const row = Math.floor((e.clientY - rect.top) / cellSize);
            
            if (row >= 0 && row < size && col >= 0 && col < size) {
              // 触发爆炸特效
              gameState.道具.bomb--;
              
              // 标记3x3范围内的方块为匹配
              for (let i = Math.max(0, row - 1); i <= Math.min(size - 1, row + 1); i++) {
                for (let j = Math.max(0, col - 1); j <= Math.min(size - 1, col + 1); j++) {
                  gameState.gameBoard[i][j].matched = true;
                }
              }
              
              // 处理匹配
              processMatches([
                Array.from({length: 9}, (_, idx) => ({
                  row: Math.max(0, row - 1) + Math.floor(idx / 3),
                  col: Math.max(0, col - 1) + (idx % 3)
                })).filter(pos => pos.row < size && pos.col < size)
              ]);
              
              boardElement.removeEventListener('click', handleBombClick);
            }
          };
          
          boardElement.addEventListener('click', handleBombClick, { once: true });
          break;
          
        case 'addSteps':
          if (gameState.道具.addSteps <= 0) {
            showToast('没有步数加成道具了！', 'warning');
            return;
          }
          
          gameState.道具.addSteps--;
          gameState.movesAllowed += 5;
          showToast('获得额外5步！', 'success');
          renderGameBoard();
          break;
      }
    }
    
    // 购买道具
    function buy道具(type) {
      let cost = 0;
      let name = '';
      
      switch (type) {
        case 'shuffle':
          cost = 30;
          name = '洗牌道具';
          break;
        case 'bomb':
          cost = 60;
          name = '爆炸道具';
          break;
        case 'addSteps':
          cost = 40;
          name = '步数加成';
          break;
      }
      
      if (gameState.balance < cost) {
        showToast('万花币不足！', 'error');
        return;
      }
      
      // 这里应该调用API扣除万花币
      gameState.balance -= cost;
      gameState.道具[type]++;
      
      showToast(`成功购买${name}`, 'success');
      updateUserInterface();
      renderGameBoard();
    }
    
    // 检查游戏是否结束
    function checkGameEnd() {
      let isCompleted = false;
      
      // 检查关卡目标是否完成
      switch (gameState.gameType) {
        case 'score':
          isCompleted = gameState.score >= gameState.targetScore;
          break;
        case 'collect':
          isCompleted = (gameState.gameTarget.collected || 0) >= gameState.gameTarget.required;
          break;
        case 'eliminate':
          isCompleted = (gameState.gameTarget.eliminated || 0) >= gameState.gameTarget.required;
          break;
        case 'boss':
          isCompleted = (gameState.gameTarget.bossesEliminated || 0) >= gameState.gameTarget.required;
          break;
      }
      
      // 检查时间是否用完
      if (gameState.timeLimit && gameState.timeRemaining <= 0) {
        isCompleted = false;
      }
      
      // 检查步数是否用完
      if (gameState.moves >= gameState.movesAllowed && !isCompleted) {
        // 步数用完，游戏结束
        endGame(false);
        return;
      }
      
      // 如果完成了目标
      if (isCompleted) {
        endGame(true);
        return;
      }
    }
    
    // 结束游戏
    function endGame(isSuccess) {
      gameState.isPlaying = false;
      
      // 停止计时器
      if (gameState.timeInterval) {
        clearInterval(gameState.timeInterval);
        gameState.timeInterval = null;
      }
      
      if (isSuccess) {
        // 通关成功
        showLevelComplete();
      } else {
        // 未通关
        showLevelFailed();
      }
    }
    
    // 显示关卡完成
    async function showLevelComplete() {
      document.getElementById('level-complete-modal').classList.remove('hidden');
      document.getElementById('level-complete-score').textContent = gameState.score;
      
      // 计算奖励
      const baseReward = gameState.levelData.reward;
      const bonusPercentage = Math.min(100, Math.floor((gameState.score - gameState.targetScore) / gameState.targetScore * 100));
      const bonus = Math.floor(baseReward * (bonusPercentage / 100));
      const totalReward = baseReward + bonus;
      
      // 连击奖励
      const comboBonus = Math.floor(gameState.comboCount * 2);
      const finalReward = totalReward + comboBonus;
      
      document.getElementById('level-reward').textContent = totalReward;
      document.getElementById('combo-bonus').textContent = comboBonus;
      document.getElementById('final-reward').textContent = finalReward;
      
      // 三星评价
      let stars = 1;
      if (gameState.score >= gameState.targetScore * 1.5) stars = 2;
      if (gameState.score >= gameState.targetScore * 2) stars = 3;
      
      const starsElement = document.getElementById('level-stars');
      starsElement.innerHTML = '';
      for (let i = 0; i < 3; i++) {
        const star = document.createElement('i');
        star.className = `fa fa-star text-2xl ${i < stars ? 'text-yellow-400' : 'text-gray-300'}`;
        starsElement.appendChild(star);
      }
      
      // 提交关卡完成
      try {
        await apiRequest('complete-level', 'POST', {
          telegram_id: gameState.user.telegram_id,
          levelNumber: gameState.currentLevel,
          score: gameState.score
        });
        
        // 更新用户数据
        await initUser();
      } catch (error) {
        console.error('提交关卡完成失败:', error);
      }
    }
    
    // 显示关卡失败
    function showLevelFailed() {
      document.getElementById('level-failed-modal').classList.remove('hidden');
      document.getElementById('failed-score').textContent = gameState.score;
      document.getElementById('failed-target').textContent = gameState.targetScore;
    }
    
    // 复活游戏
    function reviveGame() {
      showToast('观看广告复活中...', 'info');
      
      // 模拟广告播放
      setTimeout(() => {
        // 恢复5步
        gameState.movesAllowed += 5;
        gameState.isPlaying = true;
        
        // 如果是时间限制关卡，延长1分钟
        if (gameState.timeLimit) {
          gameState.timeRemaining += 60;
        }
        
        document.getElementById('level-failed-modal').classList.add('hidden');
        renderGameBoard();
        showToast('已复活，获得额外5步！', 'success');
      }, 3000);
    }
    
    // 重新开始关卡（消耗万花币）
    async function restartLevelWithCost() {
      const cost = 50;
      
      if (gameState.balance < cost) {
        showToast('万花币不足，无法重试！', 'error');
        return;
      }
      
      // 扣除万花币
      gameState.balance -= cost;
      updateUserInterface();
      
      document.getElementById('level-failed-modal').classList.add('hidden');
      startGame(gameState.currentLevel);
    }
    
    // 开始游戏
    async function startGame(levelNumber) {
      try {
        // 检查是否可以玩游戏
        const canPlay = await checkCanPlayGame();
        if (!canPlay) {
          showToast('没有剩余游戏次数，请观看广告或分享获取更多次数', 'error');
          navigateTo('home-page');
          return;
        }
        
        // 记录游戏次数
        await recordGamePlay('free');
        
        // 加载关卡数据
        const levelData = await loadLevelData(levelNumber);
        if (!levelData) return;
        
        // 初始化关卡目标
        if (levelNumber <= 10) {
          // 新手关卡 - 累计得分
          gameState.gameType = 'score';
          gameState.targetScore = levelData.target_score;
          gameState.timeLimit = 180; // 3分钟
          gameState.movesAllowed = 999; // 基本无限制
          gameState.gameTarget = {};
        } else if (levelNumber <= 20) {
          // 基础关卡 - 收集特定元素
          gameState.gameType = 'collect';
          gameState.targetScore = levelData.target_score;
          gameState.movesAllowed = levelData.moves_allowed;
          gameState.timeLimit = null;
          gameState.gameTarget = { required: 10 + Math.floor((levelNumber - 10) * 0.5) };
        } else if (levelNumber <= 40) {
          // 进阶关卡 - 消除障碍
          gameState.gameType = 'eliminate';
          gameState.targetScore = levelData.target_score;
          gameState.movesAllowed = levelData.moves_allowed;
          gameState.timeLimit = null;
          gameState.gameTarget = { required: 10 + Math.floor((levelNumber - 20) * 0.75) };
        } else {
          // 挑战关卡 - 击败BOSS
          gameState.gameType = 'boss';
          gameState.targetScore = levelData.target_score;
          gameState.movesAllowed = levelData.moves_allowed;
          gameState.timeLimit = null;
          gameState.gameTarget = { required: 3 + Math.floor((levelNumber - 40) * 0.1) };
        }
        
        // 初始化游戏状态
        gameState.isPlaying = true;
        gameState.score = 0;
        gameState.moves = 0;
        gameState.gameBoard = initializeGameBoard(levelNumber);
        gameState.comboCount = 0;
        gameState.comboMultiplier = 1;
        
        // 初始化时间
        if (gameState.timeLimit) {
          gameState.timeRemaining = gameState.timeLimit;
          
          // 设置计时器
          if (gameState.timeInterval) {
            clearInterval(gameState.timeInterval);
          }
          
          gameState.timeInterval = setInterval(() => {
            gameState.timeRemaining--;
            renderGameBoard();
            
            if (gameState.timeRemaining <= 0) {
              clearInterval(gameState.timeInterval);
              gameState.timeInterval = null;
              endGame(false);
            }
          }, 1000);
        }
        
        // 渲染游戏
        renderGameBoard();
        
        // 显示当前关卡
        document.getElementById('current-game-level').textContent = levelNumber;
      } catch (error) {
        console.error('开始游戏失败:', error);
        showToast('无法开始游戏，请重试', 'error');
        navigateTo('home-page');
      }
    }
    
    // 加载排行榜
    async function loadLeaderboard() {
      try {
        const leaderboard = await apiRequest('leaderboard');
        gameState.leaderboard = leaderboard;
        
        const leaderboardElement = document.getElementById('leaderboard-list');
        leaderboardElement.innerHTML = '';
        
        leaderboard.forEach((entry, index) => {
          const entryElement = document.createElement('div');
          entryElement.className = `flex items-center justify-between p-3 mb-2 rounded-lg transition-all ${
            index === 0 ? 'bg-yellow-50 border-2 border-yellow-300' :
            index === 1 ? 'bg-gray-50 border-2 border-gray-300' :
            index === 2 ? 'bg-orange-50 border-2 border-orange-300' :
            'bg-white hover:bg-gray-50'
          }`;
          
          entryElement.innerHTML = `
            <div class="flex items-center">
              <div class="w-8 h-8 rounded-full ${
                index === 0 ? 'bg-yellow-400' :
                index === 1 ? 'bg-gray-400' :
                index === 2 ? 'bg-orange-600' : 'bg-primary'
              } text-white flex items-center justify-center mr-3 font-bold">
                ${entry.rank}
              </div>
              <div>
                <div class="font-bold">${entry.username}</div>
                <div class="text-sm text-gray-500">总分: ${entry.score}</div>
              </div>
            </div>
            ${index === 0 ? '<i class="fa fa-trophy text-yellow-500 text-2xl"></i>' : 
              index === 1 ? '<i class="fa fa-trophy text-gray-400 text-2xl"></i>' :
              index === 2 ? '<i class="fa fa-trophy text-orange-600 text-2xl"></i>' : ''}
          `;
          
          leaderboardElement.appendChild(entryElement);
        });
        
        // 显示奖励说明
        document.getElementById('leaderboard-rewards').innerHTML = `
          <div class="p-4 bg-gray-50 rounded-lg mt-4">
            <h3 class="font-bold text-lg mb-2">月度奖励</h3>
            <div class="flex justify-between items-center mb-1">
              <span>第1名: <i class="fa fa-trophy text-yellow-500"></i></span>
              <span class="font-bold">¥100</span>
            </div>
            <div class="flex justify-between items-center mb-1">
              <span>第2名: <i class="fa fa-trophy text-gray-400"></i></span>
              <span class="font-bold">¥50</span>
            </div>
            <div class="flex justify-between items-center mb-1">
              <span>第3名: <i class="fa fa-trophy text-orange-600"></i></span>
              <span class="font-bold">¥30</span>
            </div>
            <div class="flex justify-between items-center mb-1">
              <span>第4名:</span>
              <span class="font-bold">¥20</span>
            </div>
            <div class="flex justify-between items-center">
              <span>第5名:</span>
              <span class="font-bold">¥10</span>
            </div>
            <div class="text-sm text-gray-500 mt-2">
              奖励将在每月最后一天以现金形式发放
            </div>
          </div>
        `;
      } catch (error) {
        console.error('加载排行榜失败:', error);
        showToast('无法加载排行榜，请重试', 'error');
      }
    }
    
    // 加载个人资料数据
    function loadProfileData() {
      if (!gameState.user) return;
      
      // 更新个人资料显示
      document.getElementById('profile-level').textContent = gameState.currentLevel;
      document.getElementById('profile-total-score').textContent = gameState.totalScore;
      document.getElementById('profile-balance').textContent = gameState.balance;
      
      // 模拟成就数据
      const achievements = [
        { name: "消除大师", progress: 75, target: 100, icon: "fa-star" },
        { name: "连击高手", progress: 32, target: 50, icon: "fa-trophy" },
        { name: "关卡达人", progress: gameState.currentLevel, target: 100, icon: "fa-signal" },
        { name: "社交达人", progress: 2, target: 10, icon: "fa-users" }
      ];
      
      const achievementsElement = document.getElementById('profile-achievements');
      achievementsElement.innerHTML = '';
      
      achievements.forEach(achievement => {
        const progressPercent = Math.min(100, Math.round((achievement.progress / achievement.target) * 100));
        
        const achievementElement = document.createElement('div');
        achievementElement.className = 'mb-4';
        achievementElement.innerHTML = `
          <div class="flex justify-between mb-1">
            <div class="flex items-center">
              <i class="fa ${achievement.icon} text-accent mr-2"></i>
              <span class="font-medium">${achievement.name}</span>
            </div>
            <span class="text-sm text-gray-500">${achievement.progress}/${achievement.target}</span>
          </div>
          <div class="w-full bg-gray-200 rounded-full h-2">
            <div class="bg-accent h-2 rounded-full" style="width: ${progressPercent}%"></div>
          </div>
        `;
        
        achievementsElement.appendChild(achievementElement);
      });
    }
    
    // 加载商店物品
    function loadShopItems() {
      const shopItems = [
        { 
          id: 'shuffle', 
          name: '洗牌道具', 
          description: '重新排列当前棋盘上的所有元素', 
          cost: 30, 
          icon: 'fa-random',
          count: gameState.道具.shuffle
        },
        { 
          id: 'bomb', 
          name: '爆炸道具', 
          description: '消除以选中位置为中心的3x3范围元素', 
          cost: 60, 
          icon: 'fa-bomb',
          count: gameState.道具.bomb
        },
        { 
          id: 'addSteps', 
          name: '步数加成', 
          description: '在当前关卡中额外增加5步', 
          cost: 40, 
          icon: 'fa-plus-circle',
          count: gameState.道具.addSteps
        },
        { 
          id: 'skin1', 
          name: '炫彩皮肤', 
          description: '为游戏元素换上炫彩外观', 
          cost: 300, 
          icon: 'fa-paint-brush',
          type: 'skin'
        },
        { 
          id: 'bg1', 
          name: '春日花园背景', 
          description: '棋盘背景变为春日花园', 
          cost: 200, 
          icon: 'fa-image',
          type: 'background'
        }
      ];
      
      const shopElement = document.getElementById('shop-items');
      shopElement.innerHTML = '';
      
      shopItems.forEach(item => {
        const itemElement = document.createElement('div');
        itemElement.className = 'bg-white rounded-lg p-4 mb-3 game-shadow hover:shadow-lg transition-shadow';
        
        let actionButton = '';
        if (item.type === 'skin' || item.type === 'background') {
          actionButton = `<button onclick="buyShopItem('${item.id}')" class="btn-effect bg-primary hover:bg-primary/90 text-white py-2 px-4 rounded-lg text-sm">
                            购买 (${item.cost} 万花币)
                          </button>`;
        } else {
          actionButton = `<div class="flex items-center">
                            <span class="mr-2 bg-gray-100 px-2 py-1 rounded text-sm">已拥有: ${item.count}</span>
                            <button onclick="buy道具('${item.id}')" class="btn-effect bg-primary hover:bg-primary/90 text-white py-2 px-4 rounded-lg text-sm">
                              购买 (${item.cost} 万花币)
                            </button>
                          </div>`;
        }
        
        itemElement.innerHTML = `
          <div class="flex items-start">
            <div class="text-2xl text-accent mr-3">
              <i class="fa ${item.icon}"></i>
            </div>
            <div class="flex-1">
              <h3 class="font-bold">${item.name}</h3>
              <p class="text-sm text-gray-600 mb-3">${item.description}</p>
              ${actionButton}
            </div>
          </div>
        `;
        
        shopElement.appendChild(itemElement);
      });
    }
    
    // 购买商店物品
    function buyShopItem(itemId) {
      let cost = 0;
      let name = '';
      
      switch (itemId) {
        case 'skin1':
          cost = 300;
          name = '炫彩皮肤';
          break;
        case 'bg1':
          cost = 200;
          name = '春日花园背景';
          break;
      }
      
      if (gameState.balance < cost) {
        showToast('万花币不足！', 'error');
        return;
      }
      
      // 扣除万花币
      gameState.balance -= cost;
      
      // 应用皮肤或背景
      if (itemId === 'skin1') {
        gameState.skin = 'colorful';
      } else if (itemId === 'bg1') {
        gameState.background = 'garden';
        document.getElementById('game-board').classList.add('bg-gradient-to-br', 'from-green-50', 'to-green-100');
      }
      
      showToast(`成功购买${name}`, 'success');
      updateUserInterface();
      loadShopItems();
    }
    
    // 提交提现请求
    async function submitWithdrawal() {
      const amount = parseInt(document.getElementById('withdrawal-amount').value);
      const alipayAccount = document.getElementById('alipay-account').value;
      const alipayName = document.getElementById('alipay-name').value;
      
      if (!amount || !alipayAccount || !alipayName) {
        showToast('请填写完整信息', 'error');
        return;
      }
      
      if (amount % 1000 !== 0) {
        showToast('提现金额必须是1000的倍数', 'error');
        return;
      }
      
      if (amount < 1000) {
        showToast('最低提现金额为1000万花币', 'error');
        return;
      }
      
      if (amount > gameState.balance) {
        showToast('余额不足', 'error');
        return;
      }
      
      try {
        const result = await apiRequest('withdrawal', 'POST', {
          telegram_id: gameState.user.telegram_id,
          amount,
          alipayAccount,
          alipayName
        });
        
        if (result.success) {
          showToast('提现请求已提交，等待处理', 'success');
          // 重置表单
          document.getElementById('withdrawal-form').reset();
          // 刷新余额
          await initUser();
          // 返回首页
          navigateTo('home-page');
        } else {
          showToast(result.message, 'error');
        }
      } catch (error) {
        console.error('提交提现请求失败:', error);
        showToast('提现请求失败，请重试', 'error');
      }
    }
    
    // 加载提现历史
    async function loadWithdrawalHistory() {
      try {
        const history = await apiRequest(`withdrawal-history?telegram_id=${gameState.user.telegram_id}`);
        
        const historyElement = document.getElementById('withdrawal-history');
        historyElement.innerHTML = '';
        
        if (history.length === 0) {
          historyElement.innerHTML = '<div class="text-center py-8 text-gray-500">暂无提现记录</div>';
          return;
        }
        
        history.forEach(request => {
          const statusClass = 
            request.status === 'pending' ? 'bg-yellow-100 text-yellow-800' :
            request.status === 'approved' ? 'bg-green-100 text-green-800' :
            'bg-red-100 text-red-800';
          
          const statusText = 
            request.status === 'pending' ? '处理中' :
            request.status === 'approved' ? '已批准' :
            '已拒绝';
          
          const date = new Date(request.created_at).toLocaleString();
          
          const requestElement = document.createElement('div');
          requestElement.className = 'p-3 mb-2 rounded-lg border hover:shadow-md transition-shadow';
          requestElement.innerHTML = `
            <div class="flex justify-between items-center mb-1">
              <span class="font-bold">${request.amount} 万花币</span>
              <span class="px-2 py-1 rounded text-xs ${statusClass}">${statusText}</span>
            </div>
            <div class="text-sm text-gray-600 mb-1">支付宝: ${request.alipay_account}</div>
            <div class="text-sm text-gray-600 mb-1">姓名: ${request.alipay_name}</div>
            <div class="text-xs text-gray-500">申请时间: ${date}</div>
          `;
          
          historyElement.appendChild(requestElement);
        });
      } catch (error) {
        console.error('加载提现历史失败:', error);
        showToast('无法加载提现历史，请重试', 'error');
      }
    }
    
    // 页面加载完成后初始化
    window.addEventListener('DOMContentLoaded', () => {
      // 绑定导航事件
      document.getElementById('home-btn').addEventListener('click', () => navigateTo('home-page'));
      document.getElementById('play-btn').addEventListener('click', () => navigateTo('game-page'));
      document.getElementById('leaderboard-nav-btn').addEventListener('click', () => navigateTo('leaderboard-page'));
      document.getElementById('withdrawal-nav-btn').addEventListener('click', () => {
        navigateTo('withdrawal-page');
        loadWithdrawalHistory();
      });
      document.getElementById('shop-nav-btn').addEventListener('click', () => navigateTo('shop-page'));
      document.getElementById('profile-nav-btn').addEventListener('click', () => navigateTo('profile-page'));
      
      // 绑定签到按钮
      document.getElementById('checkin-btn').addEventListener('click', handleCheckin);
      
      // 绑定广告和分享按钮
      document.getElementById('watch-ad-btn').addEventListener('click', () => addGamePlays('ad'));
      document.getElementById('share-btn').addEventListener('click', () => addGamePlays('share'));
      
      // 绑定道具使用按钮
      document.getElementById('use-shuffle').addEventListener('click', () => use道具('shuffle'));
      document.getElementById('use-bomb').addEventListener('click', () => use道具('bomb'));
      document.getElementById('use-steps').addEventListener('click', () => use道具('addSteps'));
      
      // 绑定提现按钮
      document.getElementById('submit-withdrawal-btn').addEventListener('click', submitWithdrawal);
      
      // 绑定游戏模态框按钮
      document.getElementById('next-level-btn').addEventListener('click', () => {
        document.getElementById('level-complete-modal').classList.add('hidden');
        startGame(gameState.currentLevel);
      });
      
      document.getElementById('retry-level-btn').addEventListener('click', () => {
        document.getElementById('level-failed-modal').classList.add('hidden');
        startGame(gameState.currentLevel);
      });
      
      document.getElementById('revive-btn').addEventListener('click', reviveGame);
      document.getElementById('restart-with-cost-btn').addEventListener('click', restartLevelWithCost);
      
      document.getElementById('exit-level-btn').addEventListener('click', () => {
        document.getElementById('level-complete-modal').classList.add('hidden');
        document.getElementById('level-failed-modal').classList.add('hidden');
        navigateTo('home-page');
      });
      
      // 初始化用户
      initUser();
    });
  </script>
  
  <!-- 登录页面 -->
  <div id="login-page" class="page flex flex-col items-center justify-center min-h-screen p-4">
    <div class="text-center mb-8">
      <div class="inline-block p-3 bg-primary/10 rounded-full mb-4">
        <i class="fa fa-diamond text-5xl text-primary"></i>
      </div>
      <h1 class="text-4xl font-bold text-primary mb-2 text-shadow">万花币消消乐</h1>
      <p class="text-gray-600">通过Telegram账号登录</p>
    </div>
    <button id="telegram-login-btn" class="btn-effect bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full flex items-center shadow-lg">
      <i class="fa fa-telegram mr-2 text-xl"></i> 用Telegram登录
    </button>
    
    <!-- 底部信息 -->
    <div class="absolute bottom-6 left-0 right-0 text-center text-gray-500 text-sm">
      本游戏由北京修车【万花楼】赞助<br>
      由 <a href="https://t.me/bjxc010" target="_blank" class="text-primary hover:underline">@bjxc010</a> 开发
    </div>
  </div>
  
  <!-- 首页 -->
  <div id="home-page" class="page hidden p-4">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-2xl font-bold text-primary">万花币消消乐</h1>
      <div class="flex items-center gap-2">
        <div class="bg-primary/10 text-primary px-3 py-1 rounded-full flex items-center">
          <i class="fa fa-diamond mr-1"></i>
          <span class="balance-display">0</span> 万花币
        </div>
        <button id="profile-nav-btn" class="btn-effect bg-white p-2 rounded-full shadow-md">
          <i class="fa fa-user text-primary"></i>
        </button>
      </div>
    </div>
    
    <div class="bg-white rounded-xl p-5 game-shadow mb-6">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-bold">当前进度</h2>
        <button id="checkin-btn" class="btn-effect bg-accent hover:bg-accent/80 text-dark font-bold py-1 px-4 rounded-full text-sm shadow-md">
          每日签到
        </button>
      </div>
      
      <div class="grid grid-cols-2 gap-4 mb-4">
        <div class="bg-light p-4 rounded-lg border shadow-sm hover:shadow-md transition-shadow">
          <div class="text-gray-500 text-sm mb-1">当前关卡</div>
          <div class="text-2xl font-bold" id="current-level-display">1</div>
        </div>
        <div class="bg-light p-4 rounded-lg border shadow-sm hover:shadow-md transition-shadow">
          <div class="text-gray-500 text-sm mb-1">总得分</div>
          <div class="text-2xl font-bold" id="total-score-display">0</div>
        </div>
        <div class="bg-light p-4 rounded-lg border shadow-sm hover:shadow-md transition-shadow">
          <div class="text-gray-500 text-sm mb-1">今日剩余次数</div>
          <div class="text-2xl font-bold" id="remaining-plays">6</div>
        </div>
        <div class="bg-light p-4 rounded-lg border shadow-sm hover:shadow-md transition-shadow">
          <div class="text-gray-500 text-sm mb-1">兑换比例</div>
          <div class="text-2xl font-bold">1000:10元</div>
        </div>
      </div>
      
      <button id="play-btn" class="btn-effect w-full bg-primary hover:bg-primary/80 text-white font-bold py-3 rounded-lg text-lg shadow-lg animate-pulse-slow">
        开始游戏
      </button>
    </div>
    
    <div class="grid grid-cols-2 gap-4 mb-6">
      <button id="watch-ad-btn" class="btn-effect bg-white p-4 rounded-xl game-shadow flex flex-col items-center justify-center hover:shadow-lg transition-shadow">
        <i class="fa fa-play-circle text-xl text-blue-500 mb-2"></i>
        <span>观看广告</span>
        <span class="text-sm text-gray-500">+2次游戏机会</span>
      </button>
      <button id="share-btn" class="btn-effect bg-white p-4 rounded-xl game-shadow flex flex-col items-center justify-center hover:shadow-lg transition-shadow">
        <i class="fa fa-share-alt text-xl text-green-500 mb-2"></i>
        <span>分享游戏</span>
        <span class="text-sm text-gray-500">+2次游戏机会</span>
      </button>
    </div>
    
    <!-- 底部导航 -->
    <div class="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 py-3 px-6 flex justify-around shadow-lg">
      <button id="home-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-home text-xl mb-1"></i>
        <span class="text-xs">首页</span>
      </button>
      <button id="play-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-gamepad text-xl mb-1"></i>
        <span class="text-xs">游戏</span>
      </button>
      <button id="shop-nav-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-shopping-bag text-xl mb-1"></i>
        <span class="text-xs">商店</span>
      </button>
      <button id="leaderboard-nav-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-trophy text-xl mb-1"></i>
        <span class="text-xs">排行</span>
      </button>
      <button id="withdrawal-nav-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-money text-xl mb-1"></i>
        <span class="text-xs">提现</span>
      </button>
    </div>
    
    <!-- 底部信息 -->
    <div class="absolute bottom-20 left-0 right-0 text-center text-gray-500 text-sm p-2">
      本游戏由北京修车【万花楼】赞助<br>
      由 <a href="https://t.me/bjxc010" target="_blank" class="text-primary hover:underline">@bjxc010</a> 开发
    </div>
  </div>
  
  <!-- 游戏页面 -->
  <div id="game-page" class="page hidden p-2" id="game-container">
    <div class="flex justify-between items-center mb-2">
      <button id="home-btn" class="btn-effect bg-white p-2 rounded-full shadow-md">
        <i class="fa fa-home"></i>
      </button>
      <div class="text-center">
        <h2 class="font-bold">关卡 <span id="current-game-level">1</span></h2>
      </div>
      <div class="bg-primary/10 text-primary px-2 py-1 rounded-full text-sm flex items-center">
        <i class="fa fa-diamond mr-1"></i>
        <span class="balance-display">0</span>
      </div>
    </div>
    
    <div class="bg-white rounded-lg p-3 mb-3 game-shadow">
      <div id="level-objective" class="mb-2 p-2 bg-light rounded-lg">
        <!-- 关卡目标会在这里动态显示 -->
      </div>
      <div class="grid grid-cols-3 gap-2 text-center">
        <div class="bg-light p-2 rounded">
          <div class="text-sm text-gray-500">当前得分</div>
          <div class="font-bold text-lg" id="game-score">0</div>
        </div>
        <div class="bg-light p-2 rounded">
          <div class="text-sm text-gray-500">目标得分</div>
          <div class="font-bold text-lg" id="target-score">0</div>
        </div>
        <div class="bg-light p-2 rounded">
          <div class="text-sm text-gray-500">剩余步数</div>
          <div class="font-bold text-lg" id="remaining-moves">0</div>
        </div>
      </div>
      
      <!-- 时间限制显示（仅新手关卡） -->
      <div id="time-display" class="hidden mt-2 p-2 bg-light rounded-lg text-center">
        <div class="text-sm text-gray-500">剩余时间</div>
        <div class="font-bold text-lg text-red-500" id="time-remaining">03:00</div>
      </div>
    </div>
    
    <div id="game-board" class="w-full aspect-square bg-light rounded-lg game-shadow grid gap-1 p-1 mb-3 overflow-hidden"></div>
    
    <!-- 道具栏 -->
    <div class="grid grid-cols-3 gap-2 mb-20">
      <button id="use-shuffle" class="btn-effect bg-white p-3 rounded-lg game-shadow flex flex-col items-center">
        <i class="fa fa-random text-lg text-blue-500 mb-1"></i>
        <span class="text-sm">洗牌</span>
        <span class="text-xs bg-primary/10 text-primary px-1 rounded-full">x<span id="shuffle-count">0</span></span>
        <span class="text-xs text-gray-500 mt-1">30币</span>
      </button>
      <button id="use-bomb" class="btn-effect bg-white p-3 rounded-lg game-shadow flex flex-col items-center">
        <i class="fa fa-bomb text-lg text-red-500 mb-1"></i>
        <span class="text-sm">爆炸</span>
        <span class="text-xs bg-primary/10 text-primary px-1 rounded-full">x<span id="bomb-count">0</span></span>
        <span class="text-xs text-gray-500 mt-1">60币</span>
      </button>
      <button id="use-steps" class="btn-effect bg-white p-3 rounded-lg game-shadow flex flex-col items-center">
        <i class="fa fa-plus-circle text-lg text-green-500 mb-1"></i>
        <span class="text-sm">加步数</span>
        <span class="text-xs bg-primary/10 text-primary px-1 rounded-full">x<span id="steps-count">0</span></span>
        <span class="text-xs text-gray-500 mt-1">40币</span>
      </button>
    </div>
    
    <!-- 底部导航 -->
    <div class="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 py-3 px-6 flex justify-around shadow-lg">
      <button id="home-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-home text-xl mb-1"></i>
        <span class="text-xs">首页</span>
      </button>
      <button id="play-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-gamepad text-xl mb-1"></i>
        <span class="text-xs">游戏</span>
      </button>
      <button id="shop-nav-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-shopping-bag text-xl mb-1"></i>
        <span class="text-xs">商店</span>
      </button>
      <button id="leaderboard-nav-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-trophy text-xl mb-1"></i>
        <span class="text-xs">排行</span>
      </button>
      <button id="withdrawal-nav-btn" class="flex flex-col items-center text-primary">
        <i class="fa fa-money text-xl mb-1"></i>
        <span class="text-xs">提现</span>
      </button>
    </div>
    
    <!-- 底部信息 -->
    <div class="absolute bottom-20 left-0 right-0 text-center text-gray-500 text-sm p-2">
      本游戏由北京修车【万花楼】赞助<br>
      由 <a href="https://t.me/bjxc010" target="_blank" class="text-primary hover:underline">@bjxc010</a> 开发
    </div>
  </div>
  
  <!-- 关卡完成模态框 -->
  <div id="level-complete-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden p-4">
    <div class="bg-white rounded-xl p-6 max-w-md w-full text-center">
      <div class="text-green-500 text-5xl mb-4 animate-pop">
        <i class="fa fa-check-circle"></i>
      </div>
      <h2 class="text-2xl font-bold mb-2">关卡完成！</h2>
      <p class="mb-4">恭喜你通过了关卡 <span id="completed-level">1</span></p>
      
      <div class="flex justify-center mb-4" id="level-stars">
        <!-- 星星评价会在这里动态显示 -->
      </div>
      
      <div class="bg-light p-4 rounded-lg mb-4">
        <div class="mb-2">你的得分: <span id="level-complete-score" class="font-bold">0</span></div>
        <div class="mb-2">基础奖励: <span id="level-reward" class="font-bold text-green-600">0</span> 万花币</div>
        <div class="mb-2">连击奖励: <span id="combo-bonus" class="font-bold text-accent">0</span> 万花币</div>
        <div class="text-green-600 font-bold">总奖励: <span id="final-reward">0</span> 万花币</div>
      </div>
      <div class="flex gap-2">
        <button id="exit-level-btn" class="btn-effect flex-1 bg-gray-200 hover:bg-gray-300 py-2 rounded-lg">
          返回首页
        </button>
        <button id="next-level-btn" class="btn-effect flex-1 bg-primary hover:bg-primary/80 text-white py-2 rounded-lg">
          下一关
        </button>
      </div>
    </div>
  </div>
  
  <!-- 关卡失败模态框 -->
  <div id="level-failed-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden p-4">
    <div class="bg-white rounded-xl p-6 max-w-md w-full text-center">
      <div class="text-red-500 text-5xl mb-4 animate-pop">
        <i class="fa fa-times-circle"></i>
      </div>
      <h2 class="text-2xl font-bold mb-2">挑战失败</h2>
      <p class="mb-4">再接再厉，争取通过关卡！</p>
      <div class="bg-light p-4 rounded-lg mb-4">
        <div class="mb-2">你的得分: <span id="failed-score" class="font-bold">0</span></div>
        <div class="text-red-600">目标得分: <span id="failed-target" class="font-bold">0</span></div>
      </div>
      <div class="grid grid-cols-2 gap-2 mb-2">
        <button id="revive-btn" class="btn-effect flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg">
          观看广告复活
        </button>
        <button id="restart-with-cost-btn" class="btn-effect flex-1 bg-accent hover:bg-accent/80 text-dark py-2 rounded-lg">
          花费50币重试
        </button>
      </div>
      <button id="exit-level-btn" class="btn-effect w-full mt-2 bg-gray-200 hover:bg-gray-300 py-2 rounded-lg">
        返回首页
      </button>
    </div>
  </div>
  
  <!-- 排行榜页面 -->
  <div id="leaderboard-page" class="page hidden p-4">
    <div class="flex justify-between items-center mb-6">
      <button id="home-btn" class="btn-effect bg-white p-2 rounded-full shadow-md" onclick="navigateTo('home-page')">
        <i class="fa fa-arrow-left"></i>
      </button>
      <h1 class="text-2xl font-bold text-primary">全服排行榜</h1>
      
